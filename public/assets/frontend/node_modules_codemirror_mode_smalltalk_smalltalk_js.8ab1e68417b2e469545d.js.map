{"version":3,"mappings":"kKAUC,YACD,aAEAA,qCAEA,kCACAC,0CAEAC,gBACAC,YACAA,eAGAC,kBACAD,YACAA,eACAA,YAGAE,aACAF,2BACAA,uBACAA,mBACAA,6BAGAE,mCACAF,iEAGA,sBACA,uBACAG,WAEA,cACAC,kBAEM,QACNA,kBAEM,QACN,gBACAC,SACAD,mBAEAC,6BACAD,kBAEAA,cAGM,SACN,iBACAC,qBACAA,UAEAD,mBAEM,0BACNA,qBAEM,aAAiBE,SACvBF,iBACAA,eAAuBE,QAEvB,QACAC,gBACQ,UACRA,4CAGMC,WACNH,cACAD,kBACAA,eAEM,cACNC,qBACAD,iBAEM,iBACNC,sBACAD,uEAGAA,uBAGAA,GAGAK,gBACA,0BACA,2CAGAC,gBACA,0BACA,0CAGAC,gBACA,0BACA,4CAGAC,gBACA,uBAGA,YAFAP,UAGAE,mBACAA,WAGAF,mBACAE,mBAGAA,GAGA,OACAM,sBACA,cAGAC,oBAGA,GAFAC,8BAEAV,aACA,YAGA,oCACA,2BACAU,uBAEAR,QAGAS,sBACAX,iBAGAY,qBACA,yEACA,sCAGAC,qBAKArB,6BAAuCsB,mBAhKvCtB,CAAQuB,EAAQ","names":["o","k","l","this","r","f","a","i","e","test","t","s","d","h","p","w","startState","token","n","blankLine","indent","electricChars","name","x"],"sources":["./node_modules/codemirror/mode/smalltalk/smalltalk.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode('smalltalk', function(config) {\n\n  var specialChars = /[+\\-\\/\\\\*~<>=@%|&?!.,:;^]/;\n  var keywords = /true|false|nil|self|super|thisContext/;\n\n  var Context = function(tokenizer, parent) {\n    this.next = tokenizer;\n    this.parent = parent;\n  };\n\n  var Token = function(name, context, eos) {\n    this.name = name;\n    this.context = context;\n    this.eos = eos;\n  };\n\n  var State = function() {\n    this.context = new Context(next, null);\n    this.expectVariable = true;\n    this.indentation = 0;\n    this.userIndentationDelta = 0;\n  };\n\n  State.prototype.userIndent = function(indentation) {\n    this.userIndentationDelta = indentation > 0 ? (indentation / config.indentUnit - this.indentation) : 0;\n  };\n\n  var next = function(stream, context, state) {\n    var token = new Token(null, context, false);\n    var aChar = stream.next();\n\n    if (aChar === '\"') {\n      token = nextComment(stream, new Context(nextComment, context));\n\n    } else if (aChar === '\\'') {\n      token = nextString(stream, new Context(nextString, context));\n\n    } else if (aChar === '#') {\n      if (stream.peek() === '\\'') {\n        stream.next();\n        token = nextSymbol(stream, new Context(nextSymbol, context));\n      } else {\n        if (stream.eatWhile(/[^\\s.{}\\[\\]()]/))\n          token.name = 'string-2';\n        else\n          token.name = 'meta';\n      }\n\n    } else if (aChar === '$') {\n      if (stream.next() === '<') {\n        stream.eatWhile(/[^\\s>]/);\n        stream.next();\n      }\n      token.name = 'string-2';\n\n    } else if (aChar === '|' && state.expectVariable) {\n      token.context = new Context(nextTemporaries, context);\n\n    } else if (/[\\[\\]{}()]/.test(aChar)) {\n      token.name = 'bracket';\n      token.eos = /[\\[{(]/.test(aChar);\n\n      if (aChar === '[') {\n        state.indentation++;\n      } else if (aChar === ']') {\n        state.indentation = Math.max(0, state.indentation - 1);\n      }\n\n    } else if (specialChars.test(aChar)) {\n      stream.eatWhile(specialChars);\n      token.name = 'operator';\n      token.eos = aChar !== ';'; // ; cascaded message expression\n\n    } else if (/\\d/.test(aChar)) {\n      stream.eatWhile(/[\\w\\d]/);\n      token.name = 'number';\n\n    } else if (/[\\w_]/.test(aChar)) {\n      stream.eatWhile(/[\\w\\d_]/);\n      token.name = state.expectVariable ? (keywords.test(stream.current()) ? 'keyword' : 'variable') : null;\n\n    } else {\n      token.eos = state.expectVariable;\n    }\n\n    return token;\n  };\n\n  var nextComment = function(stream, context) {\n    stream.eatWhile(/[^\"]/);\n    return new Token('comment', stream.eat('\"') ? context.parent : context, true);\n  };\n\n  var nextString = function(stream, context) {\n    stream.eatWhile(/[^']/);\n    return new Token('string', stream.eat('\\'') ? context.parent : context, false);\n  };\n\n  var nextSymbol = function(stream, context) {\n    stream.eatWhile(/[^']/);\n    return new Token('string-2', stream.eat('\\'') ? context.parent : context, false);\n  };\n\n  var nextTemporaries = function(stream, context) {\n    var token = new Token(null, context, false);\n    var aChar = stream.next();\n\n    if (aChar === '|') {\n      token.context = context.parent;\n      token.eos = true;\n\n    } else {\n      stream.eatWhile(/[^|]/);\n      token.name = 'variable';\n    }\n\n    return token;\n  };\n\n  return {\n    startState: function() {\n      return new State;\n    },\n\n    token: function(stream, state) {\n      state.userIndent(stream.indentation());\n\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var token = state.context.next(stream, state.context, state);\n      state.context = token.context;\n      state.expectVariable = token.eos;\n\n      return token.name;\n    },\n\n    blankLine: function(state) {\n      state.userIndent(0);\n    },\n\n    indent: function(state, textAfter) {\n      var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;\n      return (state.indentation + i) * config.indentUnit;\n    },\n\n    electricChars: ']'\n  };\n\n});\n\nCodeMirror.defineMIME('text/x-stsrc', {name: 'smalltalk'});\n\n});\n"],"sourceRoot":"webpack:///","file":"node_modules_codemirror_mode_smalltalk_smalltalk_js.8ab1e68417b2e469545d.js"}