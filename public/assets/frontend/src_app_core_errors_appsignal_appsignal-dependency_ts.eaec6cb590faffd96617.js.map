{"version":3,"mappings":"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","names":["O","p","R","H","ok","json","blob","clone","keys","entries","get","has","c","L","N","e","t","s","n","a","split","filter","global","window","self","this","w","transport","origin","d","T","r","C","o","u","setTimeout","l","x","i","G","method","body","Promise","statusText","F","headers","B","on","J","map","join","api_key","version","S","timestamp","name","message","backtrace","X","m","E","U","z","limit","f","h","b","error","decorators","overrides","console","key","uri","environment","revision","setAction","setParams","path","setTags","demo_sample","metadata","Object","apply","j","xhrEnabled","fetchEnabled","ignoreUrls","W","XMLHttpRequest","action","category","q","g","D","url","then","v","catch","_"],"sources":["./node_modules/isomorphic-unfetch/browser.js","./node_modules/unfetch/dist/unfetch.module.js","./node_modules/@appsignal/core/dist/esm/utils/functional.js","./node_modules/@appsignal/core/dist/esm/utils/hashmap.js","./node_modules/@appsignal/core/dist/esm/utils/error.js","./node_modules/@appsignal/core/dist/esm/utils/environment.js","./node_modules/@appsignal/core/dist/esm/serializable.js","./node_modules/@appsignal/javascript/dist/esm/environment.js","./node_modules/@appsignal/javascript/dist/esm/transports/xdomain.js","./node_modules/@appsignal/javascript/dist/esm/transports/xhr.js","./node_modules/@appsignal/javascript/dist/esm/transports/fetch.js","./node_modules/@appsignal/javascript/dist/esm/transports/node.js","./node_modules/@appsignal/javascript/dist/esm/api.js","./node_modules/@appsignal/core/dist/esm/utils/url.js","./node_modules/@appsignal/javascript/dist/esm/span.js","./node_modules/@appsignal/javascript/dist/esm/queue.js","./node_modules/@appsignal/javascript/dist/esm/dispatcher.js","./node_modules/@appsignal/javascript/dist/esm/index.js","./node_modules/@appsignal/javascript/dist/esm/version.js","./node_modules/@appsignal/plugin-breadcrumbs-network/dist/esm/index.js"],"sourcesContent":["module.exports = self.fetch || (self.fetch = require('unfetch').default || require('unfetch'));\n","export default function(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return{ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(s.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||\"get\",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+\",\"+t:t}),t(a())},s.onerror=r,s.withCredentials=\"include\"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null)})}\n","import { __read, __spread } from \"tslib\";\nexport function compose() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    if (funcs.length === 0) {\n        return function (arg) { return arg; };\n    }\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce(function (a, b) { return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return a(b.apply(void 0, __spread(args)));\n    }; });\n}\n","export function toHashMapString(obj) {\n    if (!obj)\n        return;\n    Object.keys(obj).forEach(function (k) {\n        if (typeof obj[k] === \"object\") {\n            obj[k] = JSON.stringify(obj[k]);\n        }\n        obj[k] = String(obj[k]);\n    });\n    return obj;\n}\nexport function toHashMap(obj) {\n    if (!obj)\n        return;\n    Object.keys(obj).forEach(function (k) {\n        if (typeof obj[k] === \"string\" ||\n            typeof obj[k] === \"boolean\" ||\n            typeof obj[k] === \"number\") {\n            return;\n        }\n        obj[k] = JSON.stringify(obj[k]);\n    });\n    return obj;\n}\n","export function isError(error) {\n    return (typeof error.message !== \"undefined\" &&\n        (typeof error.stacktrace !== \"undefined\" ||\n            typeof error[\"opera#sourceloc\"] !== \"undefined\" ||\n            typeof error.stack !== \"undefined\"));\n}\nexport function getStacktrace(error) {\n    if (typeof error.stacktrace !== \"undefined\" ||\n        typeof error[\"opera#sourceloc\"] !== \"undefined\") {\n        var _a = error.stacktrace, stacktrace = _a === void 0 ? \"\" : _a;\n        return stacktrace\n            .split(\"\\n\")\n            .filter(function (line) { return line !== \"\"; });\n    }\n    else if (error.stack) {\n        var _b = error.stack, stack = _b === void 0 ? \"\" : _b;\n        return stack.split(\"\\n\").filter(function (line) { return line !== \"\"; });\n    }\n    else {\n        return [\"No stacktrace available\"];\n    }\n}\n","export function isNodeEnv() {\n    return (Object.prototype.toString.call(typeof process !== \"undefined\" ? process : 0) === \"[object process]\");\n}\nexport function getGlobalObject() {\n    return (isNodeEnv()\n        ? global\n        : typeof window !== \"undefined\"\n            ? window\n            : typeof self !== \"undefined\"\n                ? self\n                : {});\n}\n","var Serializable = (function () {\n    function Serializable(data) {\n        this._data = data;\n    }\n    Serializable.prototype.toJSON = function () {\n        return JSON.stringify(this._data);\n    };\n    Serializable.prototype.serialize = function () {\n        return this._data;\n    };\n    return Serializable;\n}());\nexport { Serializable };\n","import { getGlobalObject, isNodeEnv } from \"@appsignal/core\";\nvar Environment = (function () {\n    function Environment() {\n    }\n    Environment.serialize = function () {\n        return {\n            transport: this.transport(),\n            origin: this.origin()\n        };\n    };\n    Environment.origin = function () {\n        var globals = getGlobalObject();\n        if (!globals.navigator ||\n            (globals.navigator.product === \"ReactNative\" && !globals.location)) {\n            return \"\";\n        }\n        return (globals.location.origin ||\n            globals.location.protocol + \"//\" + globals.location.hostname);\n    };\n    Environment.transport = function () {\n        var globals = getGlobalObject();\n        if (isNodeEnv() && typeof jest === \"undefined\") {\n            return \"NodeHTTP\";\n        }\n        else if (globals.XDomainRequest) {\n            return \"XDomainRequest\";\n        }\n        else if (globals.XMLHttpRequest && !globals.fetch) {\n            return \"XMLHttpRequest\";\n        }\n        else {\n            return \"fetch\";\n        }\n    };\n    Environment.supportsPromises = function () {\n        var globals = getGlobalObject();\n        return (\"Promise\" in globals &&\n            \"resolve\" in globals.Promise &&\n            \"reject\" in globals.Promise &&\n            \"all\" in globals.Promise &&\n            \"race\" in globals.Promise &&\n            (function () {\n                var resolve;\n                new globals.Promise(function (r) {\n                    resolve = r;\n                });\n                return typeof resolve === \"function\";\n            })());\n    };\n    return Environment;\n}());\nexport { Environment };\n","var XDomainTransport = (function () {\n    function XDomainTransport(url) {\n        this.url = url;\n    }\n    XDomainTransport.prototype.send = function (data) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var _a;\n            var req = new XDomainRequest();\n            var rx = new RegExp(\"^https?:\");\n            req.onload = function () { return resolve({}); };\n            req.open(\"POST\", _this.url.replace(rx, (_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.protocol));\n            setTimeout(function () {\n                try {\n                    req.send(data);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }, 0);\n        });\n    };\n    return XDomainTransport;\n}());\nexport { XDomainTransport };\n","var XHRTransport = (function () {\n    function XHRTransport(url) {\n        this.url = url;\n    }\n    XHRTransport.prototype.send = function (data) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                var req_1 = new XMLHttpRequest();\n                req_1.onreadystatechange = function () {\n                    if (req_1.readyState === XMLHttpRequest.DONE) {\n                        resolve({});\n                    }\n                };\n                req_1.open(\"POST\", _this.url);\n                req_1.send(data);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    };\n    return XHRTransport;\n}());\nexport { XHRTransport };\n","import { __awaiter, __generator } from \"tslib\";\nvar FetchTransport = (function () {\n    function FetchTransport(url, headers) {\n        this.url = url;\n    }\n    FetchTransport.prototype.send = function (data) {\n        return __awaiter(this, void 0, void 0, function () {\n            var res, statusText, ok;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, fetch(this.url, {\n                            method: \"POST\",\n                            body: data\n                        })];\n                    case 1:\n                        res = _a.sent();\n                        statusText = res.statusText, ok = res.ok;\n                        return [2, ok ? Promise.resolve({}) : Promise.reject({ statusText: statusText })];\n                }\n            });\n        });\n    };\n    return FetchTransport;\n}());\nexport { FetchTransport };\n","import https from \"https\";\nvar NodeTransport = (function () {\n    function NodeTransport(url) {\n        this.url = url;\n    }\n    NodeTransport.prototype.send = function (data) {\n        var _this = this;\n        var options = {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Content-Length\": data.length\n            }\n        };\n        return new Promise(function (resolve, reject) {\n            var req = https\n                .request(_this.url, options, function () { })\n                .on(\"error\", function (error) { return reject(error); });\n            req.write(data);\n            req.end();\n            resolve({});\n        });\n    };\n    return NodeTransport;\n}());\nexport { NodeTransport };\n","import { __awaiter, __generator } from \"tslib\";\nimport { urlEncode } from \"@appsignal/core\";\nimport { Environment } from \"./environment\";\nimport { XDomainTransport } from \"./transports/xdomain\";\nimport { XHRTransport } from \"./transports/xhr\";\nimport { FetchTransport } from \"./transports/fetch\";\nimport { NodeTransport } from \"./transports/node\";\nvar PushApi = (function () {\n    function PushApi(options) {\n        this._uri = options.uri || \"https://appsignal-endpoint.net/collect\";\n        this._apiKey = options.key;\n        this._clientVersion = options.version;\n        this._transport = this._createTransport(this._url());\n    }\n    PushApi.prototype.push = function (span) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4, this._transport.send(span.toJSON())];\n                    case 1:\n                        _a.sent();\n                        return [2, span];\n                }\n            });\n        });\n    };\n    PushApi.prototype._createTransport = function (url) {\n        switch (Environment.transport()) {\n            case \"XDomainRequest\":\n                return new XDomainTransport(url);\n            case \"XMLHttpRequest\":\n                return new XHRTransport(url);\n            case \"NodeHTTP\":\n                return new NodeTransport(url);\n            default:\n                return new FetchTransport(url);\n        }\n    };\n    PushApi.prototype._url = function () {\n        var auth = this._authorization();\n        return this._uri + \"?\" + urlEncode(auth);\n    };\n    PushApi.prototype._authorization = function () {\n        return {\n            api_key: this._apiKey,\n            version: this._clientVersion\n        };\n    };\n    return PushApi;\n}());\nexport { PushApi };\n","export function urlEncode(object) {\n    return Object.keys(object)\n        .map(function (key) { return encodeURIComponent(key) + \"=\" + encodeURIComponent(object[key]); })\n        .join(\"&\");\n}\n","import { __assign, __extends } from \"tslib\";\nimport { Serializable, getStacktrace, toHashMapString, isError } from \"@appsignal/core\";\nvar Span = (function (_super) {\n    __extends(Span, _super);\n    function Span(span) {\n        return _super.call(this, __assign({ timestamp: Math.round(new Date().getTime() / 1000), namespace: \"frontend\", error: {\n                name: \"NullError\",\n                message: \"No error has been set\",\n                backtrace: []\n            } }, span)) || this;\n    }\n    Span.prototype.setAction = function (name) {\n        if (!name || typeof name !== \"string\") {\n            return this;\n        }\n        this._data.action = name;\n        return this;\n    };\n    Span.prototype.setNamespace = function (name) {\n        if (!name || typeof name !== \"string\") {\n            return this;\n        }\n        this._data.namespace = name;\n        return this;\n    };\n    Span.prototype.setError = function (error) {\n        if (!error || !isError(error))\n            return this;\n        this._data.error = {\n            name: error.name || \"[unknown]\",\n            message: error.message,\n            backtrace: getStacktrace(error)\n        };\n        return this;\n    };\n    Span.prototype.setTags = function (tags) {\n        this._data.tags = __assign(__assign({}, this._data.tags), toHashMapString(tags));\n        return this;\n    };\n    Span.prototype.setParams = function (params) {\n        this._data.params = __assign(__assign({}, this._data.params), params);\n        return this;\n    };\n    Span.prototype.setBreadcrumbs = function (breadcrumbs) {\n        this._data.breadcrumbs = breadcrumbs;\n        return this;\n    };\n    return Span;\n}(Serializable));\nexport { Span };\n","import { __generator, __read, __spread } from \"tslib\";\nvar Queue = (function () {\n    function Queue(data) {\n        this._data = data || [];\n    }\n    Queue.prototype.clear = function () {\n        this._data = [];\n    };\n    Queue.prototype.values = function () {\n        return this._data;\n    };\n    Queue.prototype.push = function (item) {\n        var _a;\n        return Array.isArray(item)\n            ? (_a = this._data).push.apply(_a, __spread(item)) : this._data.push(item);\n    };\n    Queue.prototype.drain = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(this._data.length > 0)) return [3, 2];\n                    return [4, this._data.shift()];\n                case 1:\n                    _a.sent();\n                    return [3, 0];\n                case 2: return [2];\n            }\n        });\n    };\n    return Queue;\n}());\nexport { Queue };\n","import { __assign, __awaiter, __generator, __values } from \"tslib\";\nimport { getGlobalObject } from \"@appsignal/core\";\nvar Dispatcher = (function () {\n    function Dispatcher(queue, api, options) {\n        this._retries = 0;\n        this._timerID = 0;\n        this._duration = 0;\n        this._api = api;\n        this._queue = queue;\n        this.options = __assign({ limit: 5, initialDuration: 1000 }, options);\n        this.reset();\n    }\n    Dispatcher.prototype.schedule = function (time) {\n        var _this = this;\n        if (time === void 0) { time = this._duration; }\n        var globals = getGlobalObject();\n        var BACKOFF_FACTOR = 1.3;\n        var cb = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b, span, e_1, expDuration, e_2_1;\n            var e_2, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 7, 8, 9]);\n                        _a = __values(this._queue.drain()), _b = _a.next();\n                        _d.label = 1;\n                    case 1:\n                        if (!!_b.done) return [3, 6];\n                        span = _b.value;\n                        if (!span)\n                            return [2];\n                        _d.label = 2;\n                    case 2:\n                        _d.trys.push([2, 4, , 5]);\n                        return [4, this._api.push(span)];\n                    case 3:\n                        _d.sent();\n                        return [3, 5];\n                    case 4:\n                        e_1 = _d.sent();\n                        expDuration = Math.floor(Math.pow(time, BACKOFF_FACTOR));\n                        this._retries = this._retries - 1;\n                        if (this._retries === 0) {\n                            this.reset();\n                        }\n                        else {\n                            this._queue.push(span);\n                            this._timerID = this.schedule(expDuration);\n                        }\n                        return [2];\n                    case 5:\n                        _b = _a.next();\n                        return [3, 1];\n                    case 6: return [3, 9];\n                    case 7:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3, 9];\n                    case 8:\n                        try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                        return [7];\n                    case 9:\n                        this.reset();\n                        return [2];\n                }\n            });\n        }); };\n        return globals.setTimeout(cb, time);\n    };\n    Dispatcher.prototype.reset = function () {\n        var _a = this.options, limit = _a.limit, initialDuration = _a.initialDuration;\n        this._retries = limit;\n        this._duration = initialDuration;\n    };\n    return Dispatcher;\n}());\nexport { Dispatcher };\n","import { __assign, __awaiter, __generator, __read, __spread } from \"tslib\";\nimport { compose, toHashMap } from \"@appsignal/core\";\nimport { VERSION } from \"./version\";\nimport { PushApi } from \"./api\";\nimport { Environment } from \"./environment\";\nimport { Span } from \"./span\";\nimport { Queue } from \"./queue\";\nimport { Dispatcher } from \"./dispatcher\";\nvar Appsignal = (function () {\n    function Appsignal(options) {\n        this.VERSION = VERSION;\n        this.ignored = [];\n        this._breadcrumbs = [];\n        this._hooks = {\n            decorators: Array(),\n            overrides: Array()\n        };\n        this._env = Environment.serialize();\n        this._queue = new Queue([]);\n        var _a = options.key, key = _a === void 0 ? \"\" : _a, uri = options.uri, revision = options.revision, ignoreErrors = options.ignoreErrors;\n        if (revision && typeof revision !== \"string\") {\n            options.revision = String(revision);\n        }\n        if (key === \"\") {\n            console.info(\"[APPSIGNAL]: Started in development mode.\");\n        }\n        this._api = new PushApi({\n            key: key,\n            uri: uri,\n            version: this.VERSION\n        });\n        if (ignoreErrors && Array.isArray(ignoreErrors)) {\n            this.ignored = ignoreErrors;\n        }\n        this._dispatcher = new Dispatcher(this._queue, this._api);\n        this._options = options;\n    }\n    Appsignal.prototype.send = function (data, tagsOrFn, namespace) {\n        var _this = this;\n        if (!(data instanceof Error) && !(data instanceof Span)) {\n            console.error(\"[APPSIGNAL]: Can't send error, given error is not a valid type\");\n            return;\n        }\n        if (this.ignored.length !== 0) {\n            if (data instanceof Error &&\n                this.ignored.some(function (el) { return el.test(data.message); })) {\n                console.warn(\"[APPSIGNAL]: Ignored an error: \" + data.message);\n                return;\n            }\n            if (data instanceof Span) {\n                var error_1 = data.serialize().error;\n                if (error_1.message && this.ignored.some(function (el) { return el.test(error_1.message); })) {\n                    console.warn(\"[APPSIGNAL]: Ignored a span: \" + error_1.message);\n                    return;\n                }\n            }\n        }\n        var span = data instanceof Span ? data : this._createSpanFromError(data);\n        if (this._hooks.decorators.length > 0) {\n            compose.apply(void 0, __spread(this._hooks.decorators))(span);\n        }\n        if (tagsOrFn) {\n            if (typeof tagsOrFn === \"function\") {\n                var callback = tagsOrFn;\n                callback(span);\n            }\n            else {\n                console.warn(\"[APPSIGNAL]: DEPRECATED: Calling the `send`/`sendError` function with a tags object is deprecated. Use the callback argument instead.\");\n                var tags = (toHashMap(tagsOrFn) || {});\n                span.setTags(tags);\n            }\n        }\n        if (namespace) {\n            console.warn(\"[APPSIGNAL]: DEPRECATED: Calling the `send`/`sendError` function with a namespace is deprecated. Use the callback argument instead.\");\n            span.setNamespace(namespace);\n        }\n        if (this._breadcrumbs.length > 0)\n            span.setBreadcrumbs(this._breadcrumbs);\n        if (this._hooks.overrides.length > 0) {\n            compose.apply(void 0, __spread(this._hooks.overrides))(span);\n        }\n        if (Environment.supportsPromises()) {\n            this._breadcrumbs = [];\n            if (!this._options.key) {\n                console.warn(\"[APPSIGNAL]: Span not sent because we're in development mode:\", span);\n                if (data instanceof Error) {\n                    throw data;\n                }\n            }\n            else {\n                return this._api.push(span).catch(function () {\n                    _this._queue.push(span);\n                    setTimeout(function () { return _this._dispatcher.schedule(); }, 0);\n                });\n            }\n        }\n        else {\n            console.error(\"[APPSIGNAL]: Error not sent. A Promise polyfill is required.\");\n            return;\n        }\n    };\n    Appsignal.prototype.sendError = function (error, tagsOrFn, namespace) {\n        return this.send(error, tagsOrFn, namespace);\n    };\n    Appsignal.prototype.use = function (plugin) {\n        plugin.call(this);\n    };\n    Appsignal.prototype.createSpan = function (fn) {\n        var _a = this._options, _b = _a.revision, revision = _b === void 0 ? \"\" : _b, namespace = _a.namespace;\n        var span = new Span({\n            environment: this._env,\n            revision: revision\n        });\n        if (namespace)\n            span.setNamespace(namespace);\n        if (fn && typeof fn === \"function\")\n            fn(span);\n        return span;\n    };\n    Appsignal.prototype.wrap = function (fn, tagsOrFn, namespace) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 4]);\n                        return [4, fn()];\n                    case 1: return [2, _a.sent()];\n                    case 2:\n                        e_1 = _a.sent();\n                        return [4, this.sendError(e_1, tagsOrFn, namespace)];\n                    case 3:\n                        _a.sent();\n                        return [2, Promise.reject(e_1)];\n                    case 4: return [2];\n                }\n            });\n        });\n    };\n    Appsignal.prototype.addDecorator = function (decorator) {\n        this._hooks.decorators.push(decorator);\n    };\n    Appsignal.prototype.addOverride = function (override) {\n        this._hooks.overrides.push(override);\n    };\n    Appsignal.prototype.demo = function () {\n        var span = this._createSpanFromError(new Error(\"Hello world! This is an error used for demonstration purposes.\"));\n        span\n            .setAction(\"TestAction\")\n            .setParams({\n            path: \"/hello\",\n            method: \"GET\"\n        })\n            .setTags({\n            demo_sample: \"true\"\n        });\n        this.send(span);\n    };\n    Appsignal.prototype.addBreadcrumb = function (breadcrumb) {\n        var crumb = __assign(__assign({ timestamp: Math.round(new Date().getTime() / 1000) }, breadcrumb), { metadata: toHashMap(breadcrumb.metadata) });\n        if (!crumb.category) {\n            console.warn(\"[APPSIGNAL]: Breadcrumb not added. `category` is missing.\");\n            return;\n        }\n        if (!crumb.action) {\n            console.warn(\"[APPSIGNAL]: Breadcrumb not added. `action` is missing.\");\n            return;\n        }\n        if (this._breadcrumbs.length === 20) {\n            this._breadcrumbs.pop();\n        }\n        this._breadcrumbs.unshift(crumb);\n    };\n    Appsignal.prototype._createSpanFromError = function (error) {\n        var event = this.createSpan();\n        event.setError(error);\n        return event;\n    };\n    return Appsignal;\n}());\nexport default Appsignal;\n","export var VERSION = \"1.3.22\";\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar DEFAULTS = {\n    xhrEnabled: true,\n    fetchEnabled: true,\n    ignoreUrls: []\n};\nfunction networkBreadcrumbsPlugin(options) {\n    var opts = __assign(__assign({}, DEFAULTS), options);\n    var xhrEnabled = opts.xhrEnabled, fetchEnabled = opts.fetchEnabled, ignoreUrls = opts.ignoreUrls;\n    var isXhrEnabled = xhrEnabled ? \"XMLHttpRequest\" in window : false;\n    var isFetchEnabled = fetchEnabled ? \"fetch\" in window : false;\n    return function () {\n        var appsignal = this;\n        var xhrPatch = function () {\n            var prevOpen = XMLHttpRequest.prototype.open;\n            function open(method, url) {\n                var metadata = { method: method, url: url };\n                function onXhrLoad() {\n                    if (!ignoreUrls.some(function (el) { return el.test(url); })) {\n                        appsignal.addBreadcrumb({\n                            action: this.status >= 400\n                                ? \"Request failed with code \" + this.status\n                                : \"Received a response with code \" + this.status,\n                            category: \"XMLHttpRequest\",\n                            metadata: metadata\n                        });\n                    }\n                }\n                function onXhrError() {\n                    if (!ignoreUrls.some(function (el) { return el.test(url); })) {\n                        appsignal.addBreadcrumb({\n                            action: \"Request failed\",\n                            category: \"XMLHttpRequest\",\n                            metadata: metadata\n                        });\n                    }\n                }\n                this.addEventListener(\"load\", onXhrLoad);\n                this.addEventListener(\"error\", onXhrError);\n                prevOpen.apply(this, arguments);\n            }\n            XMLHttpRequest.prototype.open = open;\n        };\n        var fetchPatch = function () {\n            var originalFetch = window.fetch;\n            function fetch(input, init) {\n                var url = typeof input === \"string\" ? input : input.url;\n                var method = (typeof input !== \"string\" && input.method) ||\n                    (init && init.method) ||\n                    \"GET\";\n                var metadata = {\n                    method: method,\n                    url: url\n                };\n                if (ignoreUrls.some(function (el) { return el.test(url); })) {\n                    return originalFetch.apply(window, arguments);\n                }\n                return originalFetch\n                    .apply(window, arguments)\n                    .then(function (response) {\n                    var statusCode = response.status;\n                    appsignal.addBreadcrumb({\n                        action: \"Received a response with code \" + statusCode,\n                        category: \"Fetch\",\n                        metadata: metadata\n                    });\n                    return response;\n                })\n                    .catch(function (error) {\n                    appsignal.addBreadcrumb({\n                        action: \"Request failed\",\n                        category: \"Fetch\",\n                        metadata: metadata\n                    });\n                    throw error;\n                });\n            }\n            window.fetch = fetch;\n        };\n        if (isXhrEnabled)\n            xhrPatch();\n        if (isFetchEnabled)\n            fetchPatch();\n    };\n}\nexport var plugin = networkBreadcrumbsPlugin;\n"],"sourceRoot":"webpack:///","file":"src_app_core_errors_appsignal_appsignal-dependency_ts.eaec6cb590faffd96617.js"}