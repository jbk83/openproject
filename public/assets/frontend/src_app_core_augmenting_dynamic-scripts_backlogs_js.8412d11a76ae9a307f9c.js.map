{"version":3,"mappings":"iKA4BAA,EAAQ,MACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OAERA,EAAQ,OACRA,EAAQ,MACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,OACRA,EAAQ,mBChCR,MAEAA,EAFAC,EAuFCC,OArFDF,GAcAG,gBAEA,8CACAF,iCAEAA,iCAEAG,MAEAC,mBACA,cACAC,4BACAA,6EAEAC,mBACA,cACAD,4BACAA,sFAEAE,2BACA,gBACAC,qFACAH,QACA,IACAI,EADAC,iCACAC,iBACA,0BACAC,kCACA,4CAEAC,yBACA,iBACA,kBAEAL,GADAH,oDACA,GACAS,QACAL,OACAJ,aACI,cAEJG,GADAH,mDACA,GACAS,QACAL,eACI,aAEJ,OADAJ,qBACAU,QACA,SACAC,aACAA,aAEAX,EADAW,aAGAR,6BACAM,8BACAL,6BAEA,gCACA,qBAGAT,+BAEA,YACAD,yDACQ,2BAGRC,gEAFAD,0CCvCAE,8BACA,cAwBM,CACN,WACA,wCAEA,QADAe,6BACAC,KAA4BA,YAAoBA,MAChD,0BAEA,sCACAC,+CACA,OAIA,SApCAnB,QACA,WACAC,KACAD,cAEA,IAEAS,EAFAH,KACAN,iEAEA,4BACAS,YACAW,4CAEAX,YAEAH,eAAyBG,iBAKzB,wBAAqCT,UACrCU,uBAAyCV,YACzCqB,sBAAyC,GACzCV,6EC5CAA,6CAEA,WAGA,WACAV,UACAD,QACAM,QACAG,QACAM,UAGAL,KAQA,aACA,uBACAN,4BAGA,4BAyBA,eACA,uCAAyCkB,uBAGzC,cAaA,GAXAC,qBACAA,0DACA,gBAGAA,mBACAA,kEACA,iBAIAA,0BACA,2BACAC,gCACAA,mGAOAC,YAEA,OACAtB,iBACA,oDACA,kBAGAqB,0BACAA,mCA3CA,gBACA,0BACA,kBACA,+CAwCAN,uBAIAQ,kBAGA,QADAF,mCACAG,IAAsBA,WAAgBA,IACtCvB,wBAYAwB,wBACA,kBACAL,eAGAE,mBAKAF,eAGAA,oCACAA,6BAEA,mBACAC,2BAGAD,qCAEAA,sBAEAC,6BAGAD,uCAEAA,wBAIA,WAIA,cACA,mBAEA,2BACA,QACAC,2BACAA,gDAEAA,4CACA,UACA,SACAA,2BACAA,kDACAA,+CAKA,eACA,mBACAA,eACAA,4CACAA,+CAIAK,SAIA,QADAC,KACAC,KAAkBA,MAAQA,KAC1B,YAAoBC,KAAQA,IAC5BF,0CAYA,iBAGA,QAFAH,EARA,CACA,QACA,QACA,SAOAM,IAAoBA,IAAOA,IAC3B,YAAsBC,IAAOA,KAG7B,QAFAC,IAEAC,IAAwBA,IAAOA,IAC/BD,mBAGAR,UAGA,SAGA,iBACAH,wBACAA,oBACAA,sBACAA,wBACAA,0BACAA,0BACAA,4BACAA,gCACAA,gCACAA,4BACAA,4BACAA,cACAA,wBACAA,8BACAA,0BACAA,0BACAA,0BAGA,OACAa,oBACAC,uBACAC,qBACAC,gBACAC,gBACAC,iBACAC,gBACAC,yBACAC,qBACAC,gBACAC,oBACAC,oBACAC,qBACAC,oBACAC,gBACAC,yBACAC,mBACAC,kBACAC,eACAC,mBACAC,mBACAC,wBACAC,mBACAC,oBACAC,mBACAC,oBACAC,sBACAC,yBACAC,qBACAC,qBACAC,kBACAC,qBACAC,uBACAC,wBACAC,wBACAC,wBACAC,wBACAC,qBACAC,mBACAC,sBACAC,kBACAC,kBACAC,qBACAC,oBACAC,sBACAC,sBACAC,oBACAC,qBACAC,eACAC,oBACAC,eACAC,sBACAC,mBACAC,kBACAC,oBACAC,iBACAC,gBACAC,gBACAC,mBACAC,wBACAC,oBACAC,uBACAC,oBACAC,qBACAC,oBACAC,+BACAC,qBACAC,oBACAC,oBACAC,sBACAC,wBACAC,uBACAC,yBACAC,yBACAC,yBACAC,sBACAC,oBACAC,gBACAC,kBACAC,2BACAC,qBACAC,uBACAC,uBACAC,yBACAC,0BACAC,4BACAC,0BACAC,0BACAC,uBACAC,oBACAC,oBACAC,mBACAC,sBACAC,kBACAC,oBACAC,iBACAC,oBACAC,iBACAC,wBACAC,oBACAC,wBACAC,wBACAC,qBACAC,oBACAC,eACAC,eACAC,eACAC,qBACAC,oBACAC,oBACAC,sBACAC,iBACAC,qBACAC,mBACAC,mBACAC,iBACAC,kBACAC,oBACAC,oBACAC,oBACAC,eACAC,sBACAC,oBACAC,cACAC,kBACAC,iBACAC,oBACAC,iBACAC,gBACAC,qBACAC,uBAIA,eACA,uBACA5I,qBACAM,gCAEA,uCACAuI,mBAEAvI,OAEAA,EAGA,eACA,yBAGA,mBACA,iCAyBA,mBAMA,OALAN,KACAA,IACAA,KACAA,IAEA,MACAJ,YACA,MACAC,EACA,MACAD,kBAEAA,EAGA,eACA,QAGA,SADAA,aACAkJ,UACAjJ,YACM,gBAGN,QADAU,EADAD,QACAT,MACAW,IAAsBA,IAAOA,IAE7BD,GADA,qBACAwI,yBAEAC,aAEAnJ,kBAEAG,eACM,gBAENH,EA1DA,YACA,UAMA,GALAoJ,2BACAA,KACAA,IACAC,mBACAC,mBACA,KACAtJ,YACM,CACN,2BACAW,QACAX,gBACAG,YACAM,gBAGA,+BACAH,qBACAA,qBAuCAiJ,CADA9I,SAEAN,YAEAH,UAEA,OAAYwJ,iBAGZ,aACA,SADAC,WAEA,SAFAA,UAGA,SAHAA,QAIA,GAJAA,UAKA,aAIAC,MA+EA,eACA9K,QAnWA,CACA,QACA,QACA,SAkWAA,gBACAA,gBACAA,qBAGAA,wBACAA,sBAEAA,iBACAA,sBACAA,oBACAA,mBACAA,mBACAA,4BACAA,sBACAA,+BACAA,cAEA,2CACAoB,iCACAA,mCACAA,0BACAA,4BACAD,iBAEAnB,gBACAA,kBACAA,kBACAA,kBAGA,mBAwCA,qBACAmB,qBACA4J,qBACAC,SACAC,SACAC,SACAC,SACAC,MACAC,QAEAlK,gBACAA,gBA8TA,iBACA,wBACAU,UACAC,wBACAC,2BAIAA,MACAD,MAGAV,OACA,iBACA,mBACA,8BACA,iCACA,YAtbA,YACA,cACA,OACA,iBACA,QACA,kBACA,iBAEA,gBA8aAkK,gBACA,oBACA,qBAIA,qBACA,kBACAvJ,eACAC,eACAuJ,UACAC,WACA,oBAEA,SACAC,IAAmBL,SAGnBM,IAEAC,KAEA,wBACA,eACAC,WACAC,WACAC,WACAC,uBACAC,uBACAC,aACAC,cACAC,kCAGA,IACAA,SAKAA,UACAA,UAEQ,CAERV,IACAL,IAFAW,8BAEAX,SACAC,iBAGAE,OACAC,QACA,mBACAE,aACAC,gBAKA,iBACAS,sBACA,2BAUA,QAPAC,aACAC,eACAC,kBACAC,6BACAC,gCAEAC,MACAC,IAAsBA,KAAYA,KAClC,YACAD,mCAKAtL,yCACA,8BACA,kBACA,mBACA,6BACA,oBACA,0BACA,kBACA,iDACMU,iBACN,UACA,WACA8K,OACAxL,sBACA,cACAyL,YACAD,aACA,eAGA,6BAEM,CACN,sBACAE,UACAC,wBACA3L,gDACA,SA4CA,mBACA,GAPA,YACA,6CACA4L,sCACAA,qCAIAC,MAGA9L,OAEAI,IAKA,sCACAJ,uBA+LA,eACAnB,aACAA,WACAA,WACAA,WACAA,WACAA,WACAA,WACAA,gBAUA,iBAEA,OAwBA,cACAmB,qCACA+L,wBAEA,0BACAA,wBA9BAC,IACA/L,OACA,cACA,SACA,GACApB,0BACA,UACA,eACA,eACA,YACAA,mBACA,cAEAkN,iBAGAlN,gBACAA,oBACAA,sBAGA,eACA,gBAYA,eACAA,kBACAA,4CAxxBAoN,uBACApN,sBACAA,mCACAA,0BAEAA,4BAGAoN,uBAGApN,sBAGAoN,uBACA,2BACApN,wBAA4B+K,4BAC5B/K,mBACAA,oBAGAoN,uBACA,2BACApN,wBAA4B+K,4BAE5B/K,mBACAA,oBAGAoN,6BACA7L,IACAO,KACA,2BAGAuL,QAFArN,qBACAA,qBACAgC,IAkBAoL,qCAIA,2BACArL,uBAEAC,GACAoJ,0CACAC,2CAOAgC,UALA,CACAjC,6BACAC,8BAGAtJ,IAGAqL,qBACAvL,OACAN,KACA,kBAEAgK,WAznBAjL,EA0nBAkL,YA1nBAlL,EA4nBA6L,YA5nBA7L,EA6nBAmL,YA7nBAnL,EAgoBAiL,YACAA,SAIA,2BACAI,yBACA2B,0BAEAtN,wBAA4B+K,OAC5BK,MACAC,MACAkC,SACAC,YACAC,YACAC,UACAC,aAIAP,yBACApN,iBACAA,mBACAA,qBACAA,mBACAA,kBAGAoN,+BACA,wBACApN,iBAEAA,iBACAA,mBACAA,qBACAA,mBACAA,iBACAA,cAEAA,qBAGAoN,6BACA,wBACApN,iBAEAA,iBACAA,mBACAA,qBACAA,mBACAA,iBACAA,YAEAA,qBAGAoN,yCACA,yBACA,eACAtL,QACAA,QACAA,QACAA,GAGAsL,sCACAvL,OACA,+BACA,eACAG,QACAA,QACAA,QACAA,QACAA,QACAA,GAGAoL,0BACA,sBAGA3B,wBACAC,wBACAvK,4BACAA,6BAGA,eACAmM,YAMA,GAHAnM,wBACAA,wBAEA,oBACAI,eACAM,eACAG,MACAwJ,QACAW,gBACM,oBACN5K,eACAM,eACAC,eACAC,eACAC,MACAwJ,MACAW,cACM,oBAUN,2CATAnK,eACAuJ,eACAC,gBACAW,gBACA5K,eACAM,eACAC,eACAC,eAKA,4BAKAgK,MAEAC,MACAC,MAaA,GAVAF,yBACA,iCACA,qBACA,iCAAyCE,4BAOzC,iCACA,iCACA,UAGAC,iCACA,yBACA,yBACA,yBACA,oBACA,oBAIA,UACAE,0BACAC,0BACAC,4BAEAsB,gCACAA,gCAEA7B,+CACA,wDACAG,4CAGAH,oCAA2ClM,iBAG3CkM,cACA,gCACA,2BACA,qBACA,uBACA,sBACA,gCACA,iCACA,MACA,mBAEA/L,2DAGAoN,qBAWA,QALAvL,MAEAC,GAAesJ,eACfrJ,GAAeqJ,eAEfpJ,IAAoBA,2BAA8BA,MAClD,SAGAuJ,uBACA,oBACA,mCAhBA,GAgB8C,aAf9C,GAe8D,OAC9D,qBACA,+BACA,oBACA,WAIA,aAAsBE,0CAAuDA,MAC7EA,eACAF,4EAGA,4BAGA,mBACA,SACAG,EACAH,gCACA,UACA,SACAA,gCACA,UACA,QACAA,cACAG,OACA,UACA,gBACAH,aACA1L,4BACAA,4BACAA,mBACA,UACA,SACA,KACA0L,sBACA1L,oCACAA,oCACAA,oCACAA,oCACAA,gCACAA,yBAUA6L,KACA,sBACA5J,UAEA,sBACAC,UAEA,sBACAD,UAEA,sBACAC,UAIAwJ,cAEApK,EAGA0M,eAFAC,WAKAvC,0BAEAvL,2DAkIAoN,kBACApN,iBAGAoN,uBACApN,wBAA4B+K,gBAM5BqC,2BACA,cACA,OACAhC,kCAxiCA9K,EAyiCA+K,kCAziCA/K,IA6iCA8M,kBACA,SACAW,WACA/N,qBACAA,2BACAA,WA34BA,CACA,QACA,QACA,SAw4BAA,UAGAoN,qBACApN,sBACA+N,4BACA/N,6BA0BAoN,0BAOAY,WANA,CACA,QACA,QACA,SAGAhO,cAGAoN,qBACA,WACA7L,OAQAyM,WANA,CACA,QACA,SACA,SAGAhO,cAGAoN,sBACApN,mBACAA,mBAOAgO,WANA,CACA,QACA,QACA,SAGAhO,cAGAoN,kCAOAY,WANA,CACA,QACA,QACA,SAGAhO,cAGAoN,qCAOAY,QANA,CACA,QACA,QACA,UAGA,IAQAZ,gCACA,cACApL,MACAuJ,IACAC,KACAW,IAAkBf,SAClBK,MAEAC,EApsBA,cACA,SAEA,eACAnK,UAIA,0CACAQ,qBAEA,8BACAR,eACM,wBACNA,UACM,wBACNA,YACM,uBACNA,gBACM,wBACNA,aAEAA,SAKAA,aAEAA,EAuqBA0M,CA1tBA,YACA,SACA,aAGA,IACA1M,EADAhB,8BACA2N,MACA,IACA3M,eACMM,IAIN,cACAqM,4BACAC,kCACAC,+BACAC,yBACAC,gCAwsBAC,YACAvO,eAEA2L,GAvqBA,YACA,8CACAxK,sBAqqBAqN,IAEAlB,8BACA1B,gCACA,eACA,WACA,aACA,QACA,UACA,MACAA,sCACA,UACA,QACAA,sCACA,cAEAA,UAIA,8BACA,cACA,MACAO,iBACA,UACA,SACA,mBAEA,SACA,iBACA,kBACA,SACAA,kBAIA,eACA,QACAZ,IACAC,OACA,UACA,SACAD,SAIA,sCAEAE,yDACA,yCACA,iCACA,sDAEA3J,EACAgM,YAGAD,YAAiCzC,UACjC,CAAkBA,gBAGlB,qDACArJ,iDAEAgK,2BAEAN,+CACA,uCACA,oCACA,sCACAgD,MACA,4BACA,SAAmBA,OACnB,sBAEAzO,2DAGAoN,6BACApN,4BAGAoN,+BACApN,4BAGAoN,0BACA,yBAIApN,6CAHA,+GAIAA,4CAEA,kCACA,wCACAA,yC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CA,QACApI,IACAoI,IAGA,OAAqBgC,oBAYrB,aACA,MAEA3V,SACAA,0BAGA,sBACA,MACA,oBACAyL,eAGAmK,iBACAnK,mBACAA,mBACAA,mBAEAwC,OAGA,QAA4B3C,aAAqBA,GACjD,WACAC,WACAoI,WAGA,eACApI,mBACA,aACAA,iBACA,eACAoI,mBACA,aACAA,mBAGApI,oCACAoI,sCAGApI,mCACAA,+BACAoI,mCACAA,gCAEApI,8BAIAA,0BACAA,sBACAoI,0BACAA,sBAEApI,4BAEAvL,cACAA,4CACAA,kDACAA,wBACAA,oBACAA,aAIAA,0CACAA,uBACAuL,YACAoI,iBAQA,QAFAlI,4BAEAsH,IAA4BA,aAAiBA,GAC7C,IACAwB,QADAzB,eACA9I,eACA,6BA2CA,KAxCAhK,4FACAA,cAGA,kBACAuU,IAEArB,EADA,UACA,uBAEAD,6CAGAC,IAEAqB,EADA,UACA,wBAEAtB,8CAIAH,cACA9S,cACAiV,MACA,iBACAA,KAEApB,KAEA,iBACAU,mBACArB,oBAGAlT,cACAA,kBACAA,YAIAA,cACAsL,IAA4BA,mBAAuBA,GACnD,mBAEA2J,QAEAnB,kBAEA,iBACAA,uBAGA,kBACAS,WACAV,kBAEA,oBACAA,QAGAX,WACA+B,kBAEA,qBACAA,OAGA,iBACA,iBACAV,mBAEArB,oBAGAlT,cACAA,mBAGAA,YAKA0L,IACA1L,cACAA,iCACAA,mCAGAA,YA0DA,cACAsL,cAQA,YACA,sBACA,eACA2J,cACApB,cAEA7T,cACA,YAAiC4T,WAAmBA,MACpD,wBACAJ,gBAEA,oBAIA,mBACA,WACA,SAEAS,0BACA4B,gBAEA7B,eACA,WACA,SACAR,0BACAQ,QAIA,kBACA,WACA,SACAC,0BACA4B,gBAEA7B,eACA,WACA,SACAR,0BACAQ,QAIA,kBACA,WACA,SACA6B,0BACA5B,gBAEAT,eACA,WACA,SACAQ,0BACAR,QAIA,kBACA,WACA,SACAqC,0BACA5B,gBAEAT,eACA,WACA,SACAQ,0BACAR,SAGAS,aACAjU,gCAEA6T,IACAC,IACA9T,iCAEAA,WAGA,kBAUA,QATAgK,W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","names":["o","R","jQuery","init","this","bgColor","g","bgImage","fetchImageColor","Y","M","document","getContext","data","calculateYIQ","et","length","Q","it","p","setTime","L","replace","e","u","T","init_","m","initElement","V","O","at","J","A","S","P","G","aliceblue","antiquewhite","aquamarine","azure","beige","bisque","black","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","gainsboro","ghostwhite","gold","goldenrod","grey","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","limegreen","linen","magenta","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","oldlace","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","thistle","tomato","turquoise","violet","wheat","whitesmoke","yellowgreen","alpha","charAt","Math","Number","h","s","l","Dt","color","Ct","Lt","type","cp1x","cp1y","cp2x","cp2y","x","y","Kt","X","ft","ot","U","vt","rt","Tt","Ht","bt","It","Wt","Rt","ut","yt","Et","Bt","Jt","ee","ie","Gt","t","r","f","d","k","isFinite","te","Yt","Qt","K","jt","kt","radius","xStart","yStart","xEnd","yEnd","wt","Xt","Vt","ct","Pt","Nt","style","variant","weight","size","family","Zt","qt","lt","width","zt","offset","mt","G_vmlCanvasManager","CanvasRenderingContext2D","CanvasGradient","CanvasPattern","DOMException","b","exec","aqua","n","colors","legend","show","noColumns","labelFormatter","labelBoxBorderColor","container","position","margin","backgroundColor","backgroundOpacity","xaxis","mode","tickColor","transform","inverseTransform","min","max","autoscaleMargin","ticks","tickFormatter","labelWidth","labelHeight","reserveSpace","tickLength","alignTicksWithAxis","tickDecimals","tickSize","minTickSize","monthNames","timeformat","twelveHourClock","yaxis","xaxes","yaxes","series","points","lineWidth","fill","fillColor","symbol","lines","steps","bars","barWidth","align","horizontal","shadowSize","grid","aboveData","borderColor","labelMargin","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","hooks","E","left","nt","processOptions","processRawData","processDatapoints","drawSeries","draw","bindEvents","drawOverlay","shutdown","Z","_t","c","w","scale","v","I","pt","St","$t","datapoints","dt","F","push","insertSteps","a","q","D","B","isNaN","_","N","tt","H","j","direction","options","C","top","xt","allocatedAxes","second","minute","hour","day","month","year","W","ht","fmt","appendTo","height","Ut","st","label","prependTo","i","from","xmin","z","clearTimeout","Mt","Ft","padding","datapoint","dataIndex","seriesIndex","$","fn","editable","target","settings","extend","defaults","plugin","types","submit","buttons","content","element","reset","callback","onedit","onsubmit","onreset","onerror","tooltip","attr","autowidth","autoheight","each","self","savedwidth","savedheight","event","trim","html","placeholder","bind","editing","apply","preventDefault","stopPropagation","removeAttr","toLowerCase","revert","form","cssclass","css","input_content","input","loadurl","setTimeout","disabled","loadtext","loaddata","id","isFunction","ajax","loadtype","url","async","success","result","window","name","append","focus","select","keydown","keyCode","onblur","blur","val","str","innerHTML","submitdata","method","_method","indicator","ajaxoptions","dataType","status","error","xhr","unbind","removeData","original","string","match","click","cancel","text","textarea","rows","cols","String","constructor","eval","json","key","hasOwnProperty","option","children","selected","addInputType"],"sources":["./src/app/core/augmenting/dynamic-scripts/backlogs.js","./src/vendor/jquery.colorcontrast.js","./src/vendor/jquery.cookie.js","./src/vendor/jquery.flot/excanvas.js","./src/vendor/jquery.flot/jquery.flot.js","./src/vendor/jquery.jeditable.mini.js"],"sourcesContent":["//-- copyright\n// OpenProject is an open source project management software.\n// Copyright (C) 2012-2022 the OpenProject GmbH\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License version 3.\n//\n// OpenProject is a fork of ChiliProject, which is a fork of Redmine. The copyright follows:\n// Copyright (C) 2006-2013 Jean-Philippe Lang\n// Copyright (C) 2010-2013 the ChiliProject Team\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n//\n// See COPYRIGHT and LICENSE files for more details.\n//++\n\nrequire('core-vendor/jquery.flot/jquery.flot');\nrequire('core-vendor/jquery.flot/excanvas');\nrequire('core-vendor/jquery.jeditable.mini');\nrequire('core-vendor/jquery.cookie');\nrequire('core-vendor/jquery.colorcontrast');\n\nrequire('./backlogs/common');\nrequire('./backlogs/master_backlog');\nrequire('./backlogs/backlog');\nrequire('./backlogs/burndown');\nrequire('./backlogs/model');\nrequire('./backlogs/editable_inplace');\nrequire('./backlogs/sprint');\nrequire('./backlogs/work_package');\nrequire('./backlogs/story');\nrequire('./backlogs/task');\nrequire('./backlogs/impediment');\nrequire('./backlogs/taskboard');\nrequire('./backlogs/show_main');\n","/**\n * jQuery color contrast\n * @Author: \t\tJochen Vandendriessche <jochen@builtbyrobot.com>\n * @Author URI: \thttp://builtbyrobot.com\n **/\n\nfunction debug(o){\n\tvar _r = '';\n\tfor (var k in o){\n\t\t_r += 'o[' + k + '] => ' + o[k] + '\\n';\n\t}\n\twindow.alert(_r);\n}\n\n(function($){\n\n\tvar methods = {\n\t\t/*\n\t\t\tFunction: init\n\n\t\t\tInitialises the color contrast\n\n\t\t\tParameters:\n\t\t\t\tjQuery object - {object}\n\n\t\t\tExample\n\t\t\t\t> // initialise new color contrast calculator\n\t\t\t\t> $('body').colorcontrast();\n\t\t  \n\t\t*/\n\t\tinit : function() {\n\t\t\t// check if we have a background image, if not, use the backgroundcolor\n\t\t\tif ($(this).css('background-image') == 'none') {\n\t\t\t\t$(this).colorcontrast('bgColor');\n\t\t\t}else{\n\t\t\t\t$(this).colorcontrast('bgImage');\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tbgColor : function() {\n\t\t\tvar t = $(this);\n\t\t\tt.removeClass('dark light');\n\t\t\tt.addClass($(this).colorcontrast('calculateYIQ', t.css('background-color')));\n\t\t},\n\t\tbgImage : function() {\n\t\t\tvar t = $(this);\n\t\t\tt.removeClass('dark light');\n\t\t\tt.addClass($(this).colorcontrast('calculateYIQ', t.colorcontrast('fetchImageColor')));\n\t\t},\n\t\tfetchImageColor : function(){\n\t\t\tvar img = new Image();\n\t\t\tvar src = $(this).css('background-image').replace('url(', '').replace(/'/, '').replace(')', '');\n\t\t\timg.src = src;\n\t\t\tvar can = document.createElement('canvas');\t\n\t\t\tvar context = can.getContext('2d');\n\t\t\tcontext.drawImage(img, 0, 0);\n\t\t\tdata = context.getImageData(0, 0, 1, 1).data;\n\t\t\treturn 'rgb(' + data[0] + ',' + data[1] + ',' + data[2] + ')';\n\t\t},\n\t\tcalculateYIQ : function(color){\n\t\t\tvar r = 0, g = 0, b = 0, a = 1, yiq = 0;\n\t\t\tif (/rgba/.test(color)){\n\t\t\t\tcolor = color.replace('rgba(', '').replace(')', '').split(/,/);\n\t\t\t\tr = color[0];\n\t\t\t\tg = color[1];\n\t\t\t\tb = color[2];\n\t\t\t\ta = color[3];\n\t\t\t}else if (/rgb/.test(color)){\n\t\t\t\tcolor = color.replace('rgb(', '').replace(')', '').split(/,/);\n\t\t\t\tr = color[0];\n\t\t\t\tg = color[1];\n\t\t\t\tb = color[2];\n\t\t\t}else if(/#/.test(color)){\n\t\t\t\tcolor = color.replace('#', '');\n\t\t\t\tif (color.length == 3){\n\t\t\t\t\tvar _t = '';\n\t\t\t\t\t_t += color[0] + color[0];\n\t\t\t\t\t_t += color[1] + color[1];\n\t\t\t\t\t_t += color[2] + color[2];\n\t\t\t\t\tcolor = _t;\n\t\t\t\t}\n\t\t\t\tr = parseInt(color.substr(0,2),16);\n\t\t\t\tg = parseInt(color.substr(2,2),16);\n\t\t\t\tb = parseInt(color.substr(4,2),16);\n\t\t\t}\n\t\t\tyiq = ((r*299)+(g*587)+(b*114))/1000;\n\t\t\treturn (yiq >= 128) ? 'light' : 'dark';\n\t\t}\n\t};\n\t$.fn.colorcontrast = function(method){\n\t\t\n\t\tif ( methods[method] ) {\n\t\t      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));\n\t\t    } else if ( typeof method === 'object' || ! method ) {\n\t\t      return methods.init.apply( this, arguments );\n\t\t    } else {\n\t\t      $.error( 'Method ' +  method + ' does not exist on jQuery color contrast' );\n\t\t}\n\t\t\n\t}\n\t\n})(jQuery);\n","/**\n * Cookie plugin\n *\n * Copyright (c) 2006 Klaus Hartl (stilbuero.de)\n * Dual licensed under the MIT and GPL licenses:\n * http://www.opensource.org/licenses/mit-license.php\n * http://www.gnu.org/licenses/gpl.html\n *\n */\n\n/**\n * Create a cookie with the given name and value and other optional parameters.\n *\n * @example $.cookie('the_cookie', 'the_value');\n * @desc Set the value of a cookie.\n * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });\n * @desc Create a cookie with all available options.\n * @example $.cookie('the_cookie', 'the_value');\n * @desc Create a session cookie.\n * @example $.cookie('the_cookie', null);\n * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain\n *       used when the cookie was set.\n *\n * @param String name The name of the cookie.\n * @param String value The value of the cookie.\n * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.\n * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.\n *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.\n *                             If set to null or omitted, the cookie will be a session cookie and will not be retained\n *                             when the the browser exits.\n * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).\n * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).\n * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will\n *                        require a secure protocol (like HTTPS).\n * @type undefined\n *\n * @name $.cookie\n * @cat Plugins/Cookie\n * @author Klaus Hartl/klaus.hartl@stilbuero.de\n */\n\n/**\n * Get the value of a cookie with the given name.\n *\n * @example $.cookie('the_cookie');\n * @desc Get the value of a cookie.\n *\n * @param String name The name of the cookie.\n * @return The value of the cookie.\n * @type String\n *\n * @name $.cookie\n * @cat Plugins/Cookie\n * @author Klaus Hartl/klaus.hartl@stilbuero.de\n */\njQuery.cookie = function(name, value, options) {\n    if (typeof value != 'undefined') { // name and value given, set cookie\n        options = options || {};\n        if (value === null) {\n            value = '';\n            options.expires = -1;\n        }\n        var expires = '';\n        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {\n            var date;\n            if (typeof options.expires == 'number') {\n                date = new Date();\n                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));\n            } else {\n                date = options.expires;\n            }\n            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE\n        }\n        // CAUTION: Needed to parenthesize options.path and options.domain\n        // in the following expressions, otherwise they evaluate to undefined\n        // in the packed version for some reason...\n        var path = options.path ? '; path=' + (options.path) : '';\n        var domain = options.domain ? '; domain=' + (options.domain) : '';\n        var secure = options.secure ? '; secure' : '';\n        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');\n    } else { // only name given, get cookie\n        var cookieValue = null;\n        if (document.cookie && document.cookie != '') {\n            var cookies = document.cookie.split(';');\n            for (var i = 0; i < cookies.length; i++) {\n                var cookie = jQuery.trim(cookies[i]);\n                // Does this cookie string begin with the name we want?\n                if (cookie.substring(0, name.length + 1) == (name + '=')) {\n                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                    break;\n                }\n            }\n        }\n        return cookieValue;\n    }\n};","// Copyright 2006 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n// Known Issues:\n//\n// * Patterns only support repeat.\n// * Radial gradient are not implemented. The VML version of these look very\n//   different from the canvas one.\n// * Clipping paths are not implemented.\n// * Coordsize. The width and height attribute have higher priority than the\n//   width and height style values which isn't correct.\n// * Painting mode isn't implemented.\n// * Canvas width/height should is using content-box by default. IE in\n//   Quirks mode will draw the canvas using border-box. Either change your\n//   doctype to HTML5\n//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)\n//   or use Box Sizing Behavior from WebFX\n//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)\n// * Non uniform scaling does not correctly scale strokes.\n// * Filling very large shapes (above 5000 points) is buggy.\n// * Optimize. There is always room for speed improvements.\n\n// Only add this code if we do not already have a canvas implementation\nif (!document.createElement('canvas').getContext) {\n\n(function() {\n\n  // alias some functions to make (compiled) code shorter\n  var m = Math;\n  var mr = m.round;\n  var ms = m.sin;\n  var mc = m.cos;\n  var abs = m.abs;\n  var sqrt = m.sqrt;\n\n  // this is used for sub pixel precision\n  var Z = 10;\n  var Z2 = Z / 2;\n\n  /**\n   * This funtion is assigned to the <canvas> elements as element.getContext().\n   * @this {HTMLElement}\n   * @return {CanvasRenderingContext2D_}\n   */\n  function getContext() {\n    return this.context_ ||\n        (this.context_ = new CanvasRenderingContext2D_(this));\n  }\n\n  var slice = Array.prototype.slice;\n\n  /**\n   * Binds a function to an object. The returned function will always use the\n   * passed in {@code obj} as {@code this}.\n   *\n   * Example:\n   *\n   *   g = bind(f, obj, a, b)\n   *   g(c, d) // will do f.call(obj, a, b, c, d)\n   *\n   * @param {Function} f The function to bind the object to\n   * @param {Object} obj The object that should act as this when the function\n   *     is called\n   * @param {*} var_args Rest arguments that will be used as the initial\n   *     arguments when the function is called\n   * @return {Function} A new function that has bound this\n   */\n  function bind(f, obj, var_args) {\n    var a = slice.call(arguments, 2);\n    return function() {\n      return f.apply(obj, a.concat(slice.call(arguments)));\n    };\n  }\n\n  function encodeHtmlAttribute(s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  }\n\n  function addNamespacesAndStylesheet(doc) {\n    // create xmlns\n    if (!doc.namespaces['g_vml_']) {\n      doc.namespaces.add('g_vml_', 'urn:schemas-microsoft-com:vml',\n                         '#default#VML');\n\n    }\n    if (!doc.namespaces['g_o_']) {\n      doc.namespaces.add('g_o_', 'urn:schemas-microsoft-com:office:office',\n                         '#default#VML');\n    }\n\n    // Setup default CSS.  Only add one style sheet per document\n    if (!doc.styleSheets['ex_canvas_']) {\n      var ss = doc.createStyleSheet();\n      ss.owningElement.id = 'ex_canvas_';\n      ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +\n          // default size is 300x150 in Gecko and Opera\n          'text-align:left;width:300px;height:150px}';\n    }\n  }\n\n  // Add namespaces and stylesheet at startup.\n  addNamespacesAndStylesheet(document);\n\n  var G_vmlCanvasManager_ = {\n    init: function(opt_doc) {\n      if (/MSIE/.test(navigator.userAgent) && !window.opera) {\n        var doc = opt_doc || document;\n        // Create a dummy element so that IE will allow canvas elements to be\n        // recognized.\n        doc.createElement('canvas');\n        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));\n      }\n    },\n\n    init_: function(doc) {\n      // find all canvas elements\n      var els = doc.getElementsByTagName('canvas');\n      for (var i = 0; i < els.length; i++) {\n        this.initElement(els[i]);\n      }\n    },\n\n    /**\n     * Public initializes a canvas element so that it can be used as canvas\n     * element from now on. This is called automatically before the page is\n     * loaded but if you are creating elements using createElement you need to\n     * make sure this is called on the element.\n     * @param {HTMLElement} el The canvas element to initialize.\n     * @return {HTMLElement} the element that was created.\n     */\n    initElement: function(el) {\n      if (!el.getContext) {\n        el.getContext = getContext;\n\n        // Add namespaces and stylesheet to document of the element.\n        addNamespacesAndStylesheet(el.ownerDocument);\n\n        // Remove fallback content. There is no way to hide text nodes so we\n        // just remove all childNodes. We could hide all elements and remove\n        // text nodes but who really cares about the fallback content.\n        el.innerHTML = '';\n\n        // do not use inline function because that will leak memory\n        el.attachEvent('onpropertychange', onPropertyChange);\n        el.attachEvent('onresize', onResize);\n\n        var attrs = el.attributes;\n        if (attrs.width && attrs.width.specified) {\n          // TODO: use runtimeStyle and coordsize\n          // el.getContext().setWidth_(attrs.width.nodeValue);\n          el.style.width = attrs.width.nodeValue + 'px';\n        } else {\n          el.width = el.clientWidth;\n        }\n        if (attrs.height && attrs.height.specified) {\n          // TODO: use runtimeStyle and coordsize\n          // el.getContext().setHeight_(attrs.height.nodeValue);\n          el.style.height = attrs.height.nodeValue + 'px';\n        } else {\n          el.height = el.clientHeight;\n        }\n        //el.getContext().setCoordsize_()\n      }\n      return el;\n    }\n  };\n\n  function onPropertyChange(e) {\n    var el = e.srcElement;\n\n    switch (e.propertyName) {\n      case 'width':\n        el.getContext().clearRect();\n        el.style.width = el.attributes.width.nodeValue + 'px';\n        // In IE8 this does not trigger onresize.\n        el.firstChild.style.width =  el.clientWidth + 'px';\n        break;\n      case 'height':\n        el.getContext().clearRect();\n        el.style.height = el.attributes.height.nodeValue + 'px';\n        el.firstChild.style.height = el.clientHeight + 'px';\n        break;\n    }\n  }\n\n  function onResize(e) {\n    var el = e.srcElement;\n    if (el.firstChild) {\n      el.firstChild.style.width =  el.clientWidth + 'px';\n      el.firstChild.style.height = el.clientHeight + 'px';\n    }\n  }\n\n  G_vmlCanvasManager_.init();\n\n  // precompute \"00\" to \"FF\"\n  var decToHex = [];\n  for (var i = 0; i < 16; i++) {\n    for (var j = 0; j < 16; j++) {\n      decToHex[i * 16 + j] = i.toString(16) + j.toString(16);\n    }\n  }\n\n  function createMatrixIdentity() {\n    return [\n      [1, 0, 0],\n      [0, 1, 0],\n      [0, 0, 1]\n    ];\n  }\n\n  function matrixMultiply(m1, m2) {\n    var result = createMatrixIdentity();\n\n    for (var x = 0; x < 3; x++) {\n      for (var y = 0; y < 3; y++) {\n        var sum = 0;\n\n        for (var z = 0; z < 3; z++) {\n          sum += m1[x][z] * m2[z][y];\n        }\n\n        result[x][y] = sum;\n      }\n    }\n    return result;\n  }\n\n  function copyState(o1, o2) {\n    o2.fillStyle     = o1.fillStyle;\n    o2.lineCap       = o1.lineCap;\n    o2.lineJoin      = o1.lineJoin;\n    o2.lineWidth     = o1.lineWidth;\n    o2.miterLimit    = o1.miterLimit;\n    o2.shadowBlur    = o1.shadowBlur;\n    o2.shadowColor   = o1.shadowColor;\n    o2.shadowOffsetX = o1.shadowOffsetX;\n    o2.shadowOffsetY = o1.shadowOffsetY;\n    o2.strokeStyle   = o1.strokeStyle;\n    o2.globalAlpha   = o1.globalAlpha;\n    o2.font          = o1.font;\n    o2.textAlign     = o1.textAlign;\n    o2.textBaseline  = o1.textBaseline;\n    o2.arcScaleX_    = o1.arcScaleX_;\n    o2.arcScaleY_    = o1.arcScaleY_;\n    o2.lineScale_    = o1.lineScale_;\n  }\n\n  var colorData = {\n    aliceblue: '#F0F8FF',\n    antiquewhite: '#FAEBD7',\n    aquamarine: '#7FFFD4',\n    azure: '#F0FFFF',\n    beige: '#F5F5DC',\n    bisque: '#FFE4C4',\n    black: '#000000',\n    blanchedalmond: '#FFEBCD',\n    blueviolet: '#8A2BE2',\n    brown: '#A52A2A',\n    burlywood: '#DEB887',\n    cadetblue: '#5F9EA0',\n    chartreuse: '#7FFF00',\n    chocolate: '#D2691E',\n    coral: '#FF7F50',\n    cornflowerblue: '#6495ED',\n    cornsilk: '#FFF8DC',\n    crimson: '#DC143C',\n    cyan: '#00FFFF',\n    darkblue: '#00008B',\n    darkcyan: '#008B8B',\n    darkgoldenrod: '#B8860B',\n    darkgray: '#A9A9A9',\n    darkgreen: '#006400',\n    darkgrey: '#A9A9A9',\n    darkkhaki: '#BDB76B',\n    darkmagenta: '#8B008B',\n    darkolivegreen: '#556B2F',\n    darkorange: '#FF8C00',\n    darkorchid: '#9932CC',\n    darkred: '#8B0000',\n    darksalmon: '#E9967A',\n    darkseagreen: '#8FBC8F',\n    darkslateblue: '#483D8B',\n    darkslategray: '#2F4F4F',\n    darkslategrey: '#2F4F4F',\n    darkturquoise: '#00CED1',\n    darkviolet: '#9400D3',\n    deeppink: '#FF1493',\n    deepskyblue: '#00BFFF',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1E90FF',\n    firebrick: '#B22222',\n    floralwhite: '#FFFAF0',\n    forestgreen: '#228B22',\n    gainsboro: '#DCDCDC',\n    ghostwhite: '#F8F8FF',\n    gold: '#FFD700',\n    goldenrod: '#DAA520',\n    grey: '#808080',\n    greenyellow: '#ADFF2F',\n    honeydew: '#F0FFF0',\n    hotpink: '#FF69B4',\n    indianred: '#CD5C5C',\n    indigo: '#4B0082',\n    ivory: '#FFFFF0',\n    khaki: '#F0E68C',\n    lavender: '#E6E6FA',\n    lavenderblush: '#FFF0F5',\n    lawngreen: '#7CFC00',\n    lemonchiffon: '#FFFACD',\n    lightblue: '#ADD8E6',\n    lightcoral: '#F08080',\n    lightcyan: '#E0FFFF',\n    lightgoldenrodyellow: '#FAFAD2',\n    lightgreen: '#90EE90',\n    lightgrey: '#D3D3D3',\n    lightpink: '#FFB6C1',\n    lightsalmon: '#FFA07A',\n    lightseagreen: '#20B2AA',\n    lightskyblue: '#87CEFA',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#B0C4DE',\n    lightyellow: '#FFFFE0',\n    limegreen: '#32CD32',\n    linen: '#FAF0E6',\n    magenta: '#FF00FF',\n    mediumaquamarine: '#66CDAA',\n    mediumblue: '#0000CD',\n    mediumorchid: '#BA55D3',\n    mediumpurple: '#9370DB',\n    mediumseagreen: '#3CB371',\n    mediumslateblue: '#7B68EE',\n    mediumspringgreen: '#00FA9A',\n    mediumturquoise: '#48D1CC',\n    mediumvioletred: '#C71585',\n    midnightblue: '#191970',\n    mintcream: '#F5FFFA',\n    mistyrose: '#FFE4E1',\n    moccasin: '#FFE4B5',\n    navajowhite: '#FFDEAD',\n    oldlace: '#FDF5E6',\n    olivedrab: '#6B8E23',\n    orange: '#FFA500',\n    orangered: '#FF4500',\n    orchid: '#DA70D6',\n    palegoldenrod: '#EEE8AA',\n    palegreen: '#98FB98',\n    paleturquoise: '#AFEEEE',\n    palevioletred: '#DB7093',\n    papayawhip: '#FFEFD5',\n    peachpuff: '#FFDAB9',\n    peru: '#CD853F',\n    pink: '#FFC0CB',\n    plum: '#DDA0DD',\n    powderblue: '#B0E0E6',\n    rosybrown: '#BC8F8F',\n    royalblue: '#4169E1',\n    saddlebrown: '#8B4513',\n    salmon: '#FA8072',\n    sandybrown: '#F4A460',\n    seagreen: '#2E8B57',\n    seashell: '#FFF5EE',\n    sienna: '#A0522D',\n    skyblue: '#87CEEB',\n    slateblue: '#6A5ACD',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#FFFAFA',\n    springgreen: '#00FF7F',\n    steelblue: '#4682B4',\n    tan: '#D2B48C',\n    thistle: '#D8BFD8',\n    tomato: '#FF6347',\n    turquoise: '#40E0D0',\n    violet: '#EE82EE',\n    wheat: '#F5DEB3',\n    whitesmoke: '#F5F5F5',\n    yellowgreen: '#9ACD32'\n  };\n\n\n  function getRgbHslContent(styleString) {\n    var start = styleString.indexOf('(', 3);\n    var end = styleString.indexOf(')', start + 1);\n    var parts = styleString.substring(start + 1, end).split(',');\n    // add alpha if needed\n    if (parts.length == 4 && styleString.substr(3, 1) == 'a') {\n      alpha = Number(parts[3]);\n    } else {\n      parts[3] = 1;\n    }\n    return parts;\n  }\n\n  function percent(s) {\n    return parseFloat(s) / 100;\n  }\n\n  function clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  }\n\n  function hslToRgb(parts){\n    var r, g, b;\n    h = parseFloat(parts[0]) / 360 % 360;\n    if (h < 0)\n      h++;\n    s = clamp(percent(parts[1]), 0, 1);\n    l = clamp(percent(parts[2]), 0, 1);\n    if (s == 0) {\n      r = g = b = l; // achromatic\n    } else {\n      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n      var p = 2 * l - q;\n      r = hueToRgb(p, q, h + 1 / 3);\n      g = hueToRgb(p, q, h);\n      b = hueToRgb(p, q, h - 1 / 3);\n    }\n\n    return '#' + decToHex[Math.floor(r * 255)] +\n        decToHex[Math.floor(g * 255)] +\n        decToHex[Math.floor(b * 255)];\n  }\n\n  function hueToRgb(m1, m2, h) {\n    if (h < 0)\n      h++;\n    if (h > 1)\n      h--;\n\n    if (6 * h < 1)\n      return m1 + (m2 - m1) * 6 * h;\n    else if (2 * h < 1)\n      return m2;\n    else if (3 * h < 2)\n      return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n    else\n      return m1;\n  }\n\n  function processStyle(styleString) {\n    var str, alpha = 1;\n\n    styleString = String(styleString);\n    if (styleString.charAt(0) == '#') {\n      str = styleString;\n    } else if (/^rgb/.test(styleString)) {\n      var parts = getRgbHslContent(styleString);\n      var str = '#', n;\n      for (var i = 0; i < 3; i++) {\n        if (parts[i].indexOf('%') != -1) {\n          n = Math.floor(percent(parts[i]) * 255);\n        } else {\n          n = Number(parts[i]);\n        }\n        str += decToHex[clamp(n, 0, 255)];\n      }\n      alpha = parts[3];\n    } else if (/^hsl/.test(styleString)) {\n      var parts = getRgbHslContent(styleString);\n      str = hslToRgb(parts);\n      alpha = parts[3];\n    } else {\n      str = colorData[styleString] || styleString;\n    }\n    return {color: str, alpha: alpha};\n  }\n\n  var DEFAULT_STYLE = {\n    style: 'normal',\n    variant: 'normal',\n    weight: 'normal',\n    size: 10,\n    family: 'sans-serif'\n  };\n\n  // Internal text style cache\n  var fontStyleCache = {};\n\n  function processFontStyle(styleString) {\n    if (fontStyleCache[styleString]) {\n      return fontStyleCache[styleString];\n    }\n\n    var el = document.createElement('div');\n    var style = el.style;\n    try {\n      style.font = styleString;\n    } catch (ex) {\n      // Ignore failures to set to invalid font.\n    }\n\n    return fontStyleCache[styleString] = {\n      style: style.fontStyle || DEFAULT_STYLE.style,\n      variant: style.fontVariant || DEFAULT_STYLE.variant,\n      weight: style.fontWeight || DEFAULT_STYLE.weight,\n      size: style.fontSize || DEFAULT_STYLE.size,\n      family: style.fontFamily || DEFAULT_STYLE.family\n    };\n  }\n\n  function getComputedStyle(style, element) {\n    var computedStyle = {};\n\n    for (var p in style) {\n      computedStyle[p] = style[p];\n    }\n\n    // Compute the size\n    var canvasFontSize = parseFloat(element.currentStyle.fontSize),\n        fontSize = parseFloat(style.size);\n\n    if (typeof style.size == 'number') {\n      computedStyle.size = style.size;\n    } else if (style.size.indexOf('px') != -1) {\n      computedStyle.size = fontSize;\n    } else if (style.size.indexOf('em') != -1) {\n      computedStyle.size = canvasFontSize * fontSize;\n    } else if(style.size.indexOf('%') != -1) {\n      computedStyle.size = (canvasFontSize / 100) * fontSize;\n    } else if (style.size.indexOf('pt') != -1) {\n      computedStyle.size = fontSize / .75;\n    } else {\n      computedStyle.size = canvasFontSize;\n    }\n\n    // Different scaling between normal text and VML text. This was found using\n    // trial and error to get the same size as non VML text.\n    computedStyle.size *= 0.981;\n\n    return computedStyle;\n  }\n\n  function buildStyle(style) {\n    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +\n        style.size + 'px ' + style.family;\n  }\n\n  function processLineCap(lineCap) {\n    switch (lineCap) {\n      case 'butt':\n        return 'flat';\n      case 'round':\n        return 'round';\n      case 'square':\n      default:\n        return 'square';\n    }\n  }\n\n  /**\n   * This class implements CanvasRenderingContext2D interface as described by\n   * the WHATWG.\n   * @param {HTMLElement} surfaceElement The element that the 2D context should\n   * be associated with\n   */\n  function CanvasRenderingContext2D_(surfaceElement) {\n    this.m_ = createMatrixIdentity();\n\n    this.mStack_ = [];\n    this.aStack_ = [];\n    this.currentPath_ = [];\n\n    // Canvas context properties\n    this.strokeStyle = '#000';\n    this.fillStyle = '#000';\n\n    this.lineWidth = 1;\n    this.lineJoin = 'miter';\n    this.lineCap = 'butt';\n    this.miterLimit = Z * 1;\n    this.globalAlpha = 1;\n    this.font = '10px sans-serif';\n    this.textAlign = 'left';\n    this.textBaseline = 'alphabetic';\n    this.canvas = surfaceElement;\n\n    var el = surfaceElement.ownerDocument.createElement('div');\n    el.style.width =  surfaceElement.clientWidth + 'px';\n    el.style.height = surfaceElement.clientHeight + 'px';\n    el.style.overflow = 'hidden';\n    el.style.position = 'absolute';\n    surfaceElement.appendChild(el);\n\n    this.element_ = el;\n    this.arcScaleX_ = 1;\n    this.arcScaleY_ = 1;\n    this.lineScale_ = 1;\n  }\n\n  var contextPrototype = CanvasRenderingContext2D_.prototype;\n  contextPrototype.clearRect = function() {\n    if (this.textMeasureEl_) {\n      this.textMeasureEl_.removeNode(true);\n      this.textMeasureEl_ = null;\n    }\n    this.element_.innerHTML = '';\n  };\n\n  contextPrototype.beginPath = function() {\n    // TODO: Branch current matrix so that save/restore has no effect\n    //       as per safari docs.\n    this.currentPath_ = [];\n  };\n\n  contextPrototype.moveTo = function(aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    this.currentPath_.push({type: 'moveTo', x: p.x, y: p.y});\n    this.currentX_ = p.x;\n    this.currentY_ = p.y;\n  };\n\n  contextPrototype.lineTo = function(aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    this.currentPath_.push({type: 'lineTo', x: p.x, y: p.y});\n\n    this.currentX_ = p.x;\n    this.currentY_ = p.y;\n  };\n\n  contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,\n                                            aCP2x, aCP2y,\n                                            aX, aY) {\n    var p = this.getCoords_(aX, aY);\n    var cp1 = this.getCoords_(aCP1x, aCP1y);\n    var cp2 = this.getCoords_(aCP2x, aCP2y);\n    bezierCurveTo(this, cp1, cp2, p);\n  };\n\n  // Helper function that takes the already fixed cordinates.\n  function bezierCurveTo(self, cp1, cp2, p) {\n    self.currentPath_.push({\n      type: 'bezierCurveTo',\n      cp1x: cp1.x,\n      cp1y: cp1.y,\n      cp2x: cp2.x,\n      cp2y: cp2.y,\n      x: p.x,\n      y: p.y\n    });\n    self.currentX_ = p.x;\n    self.currentY_ = p.y;\n  }\n\n  contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {\n    // the following is lifted almost directly from\n    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes\n\n    var cp = this.getCoords_(aCPx, aCPy);\n    var p = this.getCoords_(aX, aY);\n\n    var cp1 = {\n      x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),\n      y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)\n    };\n    var cp2 = {\n      x: cp1.x + (p.x - this.currentX_) / 3.0,\n      y: cp1.y + (p.y - this.currentY_) / 3.0\n    };\n\n    bezierCurveTo(this, cp1, cp2, p);\n  };\n\n  contextPrototype.arc = function(aX, aY, aRadius,\n                                  aStartAngle, aEndAngle, aClockwise) {\n    aRadius *= Z;\n    var arcType = aClockwise ? 'at' : 'wa';\n\n    var xStart = aX + mc(aStartAngle) * aRadius - Z2;\n    var yStart = aY + ms(aStartAngle) * aRadius - Z2;\n\n    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;\n    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;\n\n    // IE won't render arches drawn counter clockwise if xStart == xEnd.\n    if (xStart == xEnd && !aClockwise) {\n      xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something\n                       // that can be represented in binary\n    }\n\n    var p = this.getCoords_(aX, aY);\n    var pStart = this.getCoords_(xStart, yStart);\n    var pEnd = this.getCoords_(xEnd, yEnd);\n\n    this.currentPath_.push({type: arcType,\n                           x: p.x,\n                           y: p.y,\n                           radius: aRadius,\n                           xStart: pStart.x,\n                           yStart: pStart.y,\n                           xEnd: pEnd.x,\n                           yEnd: pEnd.y});\n\n  };\n\n  contextPrototype.rect = function(aX, aY, aWidth, aHeight) {\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n  };\n\n  contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {\n    var oldPath = this.currentPath_;\n    this.beginPath();\n\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n    this.stroke();\n\n    this.currentPath_ = oldPath;\n  };\n\n  contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {\n    var oldPath = this.currentPath_;\n    this.beginPath();\n\n    this.moveTo(aX, aY);\n    this.lineTo(aX + aWidth, aY);\n    this.lineTo(aX + aWidth, aY + aHeight);\n    this.lineTo(aX, aY + aHeight);\n    this.closePath();\n    this.fill();\n\n    this.currentPath_ = oldPath;\n  };\n\n  contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {\n    var gradient = new CanvasGradient_('gradient');\n    gradient.x0_ = aX0;\n    gradient.y0_ = aY0;\n    gradient.x1_ = aX1;\n    gradient.y1_ = aY1;\n    return gradient;\n  };\n\n  contextPrototype.createRadialGradient = function(aX0, aY0, aR0,\n                                                   aX1, aY1, aR1) {\n    var gradient = new CanvasGradient_('gradientradial');\n    gradient.x0_ = aX0;\n    gradient.y0_ = aY0;\n    gradient.r0_ = aR0;\n    gradient.x1_ = aX1;\n    gradient.y1_ = aY1;\n    gradient.r1_ = aR1;\n    return gradient;\n  };\n\n  contextPrototype.drawImage = function(image, var_args) {\n    var dx, dy, dw, dh, sx, sy, sw, sh;\n\n    // to find the original width we overide the width and height\n    var oldRuntimeWidth = image.runtimeStyle.width;\n    var oldRuntimeHeight = image.runtimeStyle.height;\n    image.runtimeStyle.width = 'auto';\n    image.runtimeStyle.height = 'auto';\n\n    // get the original size\n    var w = image.width;\n    var h = image.height;\n\n    // and remove overides\n    image.runtimeStyle.width = oldRuntimeWidth;\n    image.runtimeStyle.height = oldRuntimeHeight;\n\n    if (arguments.length == 3) {\n      dx = arguments[1];\n      dy = arguments[2];\n      sx = sy = 0;\n      sw = dw = w;\n      sh = dh = h;\n    } else if (arguments.length == 5) {\n      dx = arguments[1];\n      dy = arguments[2];\n      dw = arguments[3];\n      dh = arguments[4];\n      sx = sy = 0;\n      sw = w;\n      sh = h;\n    } else if (arguments.length == 9) {\n      sx = arguments[1];\n      sy = arguments[2];\n      sw = arguments[3];\n      sh = arguments[4];\n      dx = arguments[5];\n      dy = arguments[6];\n      dw = arguments[7];\n      dh = arguments[8];\n    } else {\n      throw Error('Invalid number of arguments');\n    }\n\n    var d = this.getCoords_(dx, dy);\n\n    var w2 = sw / 2;\n    var h2 = sh / 2;\n\n    var vmlStr = [];\n\n    var W = 10;\n    var H = 10;\n\n    // For some reason that I've now forgotten, using divs didn't work\n    vmlStr.push(' <g_vml_:group',\n                ' coordsize=\"', Z * W, ',', Z * H, '\"',\n                ' coordorigin=\"0,0\"' ,\n                ' style=\"width:', W, 'px;height:', H, 'px;position:absolute;');\n\n    // If filters are necessary (rotation exists), create them\n    // filters are bog-slow, so only create them if abbsolutely necessary\n    // The following check doesn't account for skews (which don't exist\n    // in the canvas spec (yet) anyway.\n\n    if (this.m_[0][0] != 1 || this.m_[0][1] ||\n        this.m_[1][1] != 1 || this.m_[1][0]) {\n      var filter = [];\n\n      // Note the 12/21 reversal\n      filter.push('M11=', this.m_[0][0], ',',\n                  'M12=', this.m_[1][0], ',',\n                  'M21=', this.m_[0][1], ',',\n                  'M22=', this.m_[1][1], ',',\n                  'Dx=', mr(d.x / Z), ',',\n                  'Dy=', mr(d.y / Z), '');\n\n      // Bounding box calculation (need to minimize displayed area so that\n      // filters don't waste time on unused pixels.\n      var max = d;\n      var c2 = this.getCoords_(dx + dw, dy);\n      var c3 = this.getCoords_(dx, dy + dh);\n      var c4 = this.getCoords_(dx + dw, dy + dh);\n\n      max.x = m.max(max.x, c2.x, c3.x, c4.x);\n      max.y = m.max(max.y, c2.y, c3.y, c4.y);\n\n      vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),\n                  'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',\n                  filter.join(''), \", sizingmethod='clip');\");\n\n    } else {\n      vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');\n    }\n\n    vmlStr.push(' \">' ,\n                '<g_vml_:image src=\"', image.src, '\"',\n                ' style=\"width:', Z * dw, 'px;',\n                ' height:', Z * dh, 'px\"',\n                ' cropleft=\"', sx / w, '\"',\n                ' croptop=\"', sy / h, '\"',\n                ' cropright=\"', (w - sx - sw) / w, '\"',\n                ' cropbottom=\"', (h - sy - sh) / h, '\"',\n                ' />',\n                '</g_vml_:group>');\n\n    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));\n  };\n\n  contextPrototype.stroke = function(aFill) {\n    var W = 10;\n    var H = 10;\n    // Divide the shape into chunks if it's too long because IE has a limit\n    // somewhere for how long a VML shape can be. This simple division does\n    // not work with fills, only strokes, unfortunately.\n    var chunkSize = 5000;\n\n    var min = {x: null, y: null};\n    var max = {x: null, y: null};\n\n    for (var j = 0; j < this.currentPath_.length; j += chunkSize) {\n      var lineStr = [];\n      var lineOpen = false;\n\n      lineStr.push('<g_vml_:shape',\n                   ' filled=\"', !!aFill, '\"',\n                   ' style=\"position:absolute;width:', W, 'px;height:', H, 'px;\"',\n                   ' coordorigin=\"0,0\"',\n                   ' coordsize=\"', Z * W, ',', Z * H, '\"',\n                   ' stroked=\"', !aFill, '\"',\n                   ' path=\"');\n\n      var newSeq = false;\n\n      for (var i = j; i < Math.min(j + chunkSize, this.currentPath_.length); i++) {\n        if (i % chunkSize == 0 && i > 0) { // move into position for next chunk\n          lineStr.push(' m ', mr(this.currentPath_[i-1].x), ',', mr(this.currentPath_[i-1].y));\n        }\n\n        var p = this.currentPath_[i];\n        var c;\n\n        switch (p.type) {\n          case 'moveTo':\n            c = p;\n            lineStr.push(' m ', mr(p.x), ',', mr(p.y));\n            break;\n          case 'lineTo':\n            lineStr.push(' l ', mr(p.x), ',', mr(p.y));\n            break;\n          case 'close':\n            lineStr.push(' x ');\n            p = null;\n            break;\n          case 'bezierCurveTo':\n            lineStr.push(' c ',\n                         mr(p.cp1x), ',', mr(p.cp1y), ',',\n                         mr(p.cp2x), ',', mr(p.cp2y), ',',\n                         mr(p.x), ',', mr(p.y));\n            break;\n          case 'at':\n          case 'wa':\n            lineStr.push(' ', p.type, ' ',\n                         mr(p.x - this.arcScaleX_ * p.radius), ',',\n                         mr(p.y - this.arcScaleY_ * p.radius), ' ',\n                         mr(p.x + this.arcScaleX_ * p.radius), ',',\n                         mr(p.y + this.arcScaleY_ * p.radius), ' ',\n                         mr(p.xStart), ',', mr(p.yStart), ' ',\n                         mr(p.xEnd), ',', mr(p.yEnd));\n            break;\n        }\n  \n  \n        // TODO: Following is broken for curves due to\n        //       move to proper paths.\n  \n        // Figure out dimensions so we can do gradient fills\n        // properly\n        if (p) {\n          if (min.x == null || p.x < min.x) {\n            min.x = p.x;\n          }\n          if (max.x == null || p.x > max.x) {\n            max.x = p.x;\n          }\n          if (min.y == null || p.y < min.y) {\n            min.y = p.y;\n          }\n          if (max.y == null || p.y > max.y) {\n            max.y = p.y;\n          }\n        }\n      }\n      lineStr.push(' \">');\n  \n      if (!aFill) {\n        appendStroke(this, lineStr);\n      } else {\n        appendFill(this, lineStr, min, max);\n      }\n  \n      lineStr.push('</g_vml_:shape>');\n  \n      this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\n    }\n  };\n\n  function appendStroke(ctx, lineStr) {\n    var a = processStyle(ctx.strokeStyle);\n    var color = a.color;\n    var opacity = a.alpha * ctx.globalAlpha;\n    var lineWidth = ctx.lineScale_ * ctx.lineWidth;\n\n    // VML cannot correctly render a line if the width is less than 1px.\n    // In that case, we dilute the color to make the line look thinner.\n    if (lineWidth < 1) {\n      opacity *= lineWidth;\n    }\n\n    lineStr.push(\n      '<g_vml_:stroke',\n      ' opacity=\"', opacity, '\"',\n      ' joinstyle=\"', ctx.lineJoin, '\"',\n      ' miterlimit=\"', ctx.miterLimit, '\"',\n      ' endcap=\"', processLineCap(ctx.lineCap), '\"',\n      ' weight=\"', lineWidth, 'px\"',\n      ' color=\"', color, '\" />'\n    );\n  }\n\n  function appendFill(ctx, lineStr, min, max) {\n    var fillStyle = ctx.fillStyle;\n    var arcScaleX = ctx.arcScaleX_;\n    var arcScaleY = ctx.arcScaleY_;\n    var width = max.x - min.x;\n    var height = max.y - min.y;\n    if (fillStyle instanceof CanvasGradient_) {\n      // TODO: Gradients transformed with the transformation matrix.\n      var angle = 0;\n      var focus = {x: 0, y: 0};\n\n      // additional offset\n      var shift = 0;\n      // scale factor for offset\n      var expansion = 1;\n\n      if (fillStyle.type_ == 'gradient') {\n        var x0 = fillStyle.x0_ / arcScaleX;\n        var y0 = fillStyle.y0_ / arcScaleY;\n        var x1 = fillStyle.x1_ / arcScaleX;\n        var y1 = fillStyle.y1_ / arcScaleY;\n        var p0 = ctx.getCoords_(x0, y0);\n        var p1 = ctx.getCoords_(x1, y1);\n        var dx = p1.x - p0.x;\n        var dy = p1.y - p0.y;\n        angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\n        // The angle should be a non-negative number.\n        if (angle < 0) {\n          angle += 360;\n        }\n\n        // Very small angles produce an unexpected result because they are\n        // converted to a scientific notation string.\n        if (angle < 1e-6) {\n          angle = 0;\n        }\n      } else {\n        var p0 = ctx.getCoords_(fillStyle.x0_, fillStyle.y0_);\n        focus = {\n          x: (p0.x - min.x) / width,\n          y: (p0.y - min.y) / height\n        };\n\n        width  /= arcScaleX * Z;\n        height /= arcScaleY * Z;\n        var dimension = m.max(width, height);\n        shift = 2 * fillStyle.r0_ / dimension;\n        expansion = 2 * fillStyle.r1_ / dimension - shift;\n      }\n\n      // We need to sort the color stops in ascending order by offset,\n      // otherwise IE won't interpret it correctly.\n      var stops = fillStyle.colors_;\n      stops.sort(function(cs1, cs2) {\n        return cs1.offset - cs2.offset;\n      });\n\n      var length = stops.length;\n      var color1 = stops[0].color;\n      var color2 = stops[length - 1].color;\n      var opacity1 = stops[0].alpha * ctx.globalAlpha;\n      var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;\n\n      var colors = [];\n      for (var i = 0; i < length; i++) {\n        var stop = stops[i];\n        colors.push(stop.offset * expansion + shift + ' ' + stop.color);\n      }\n\n      // When colors attribute is used, the meanings of opacity and o:opacity2\n      // are reversed.\n      lineStr.push('<g_vml_:fill type=\"', fillStyle.type_, '\"',\n                   ' method=\"none\" focus=\"100%\"',\n                   ' color=\"', color1, '\"',\n                   ' color2=\"', color2, '\"',\n                   ' colors=\"', colors.join(','), '\"',\n                   ' opacity=\"', opacity2, '\"',\n                   ' g_o_:opacity2=\"', opacity1, '\"',\n                   ' angle=\"', angle, '\"',\n                   ' focusposition=\"', focus.x, ',', focus.y, '\" />');\n    } else if (fillStyle instanceof CanvasPattern_) {\n      if (width && height) {\n        var deltaLeft = -min.x;\n        var deltaTop = -min.y;\n        lineStr.push('<g_vml_:fill',\n                     ' position=\"',\n                     deltaLeft / width * arcScaleX * arcScaleX, ',',\n                     deltaTop / height * arcScaleY * arcScaleY, '\"',\n                     ' type=\"tile\"',\n                     // TODO: Figure out the correct size to fit the scale.\n                     //' size=\"', w, 'px ', h, 'px\"',\n                     ' src=\"', fillStyle.src_, '\" />');\n       }\n    } else {\n      var a = processStyle(ctx.fillStyle);\n      var color = a.color;\n      var opacity = a.alpha * ctx.globalAlpha;\n      lineStr.push('<g_vml_:fill color=\"', color, '\" opacity=\"', opacity,\n                   '\" />');\n    }\n  }\n\n  contextPrototype.fill = function() {\n    this.stroke(true);\n  };\n\n  contextPrototype.closePath = function() {\n    this.currentPath_.push({type: 'close'});\n  };\n\n  /**\n   * @private\n   */\n  contextPrototype.getCoords_ = function(aX, aY) {\n    var m = this.m_;\n    return {\n      x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,\n      y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2\n    };\n  };\n\n  contextPrototype.save = function() {\n    var o = {};\n    copyState(this, o);\n    this.aStack_.push(o);\n    this.mStack_.push(this.m_);\n    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);\n  };\n\n  contextPrototype.restore = function() {\n    if (this.aStack_.length) {\n      copyState(this.aStack_.pop(), this);\n      this.m_ = this.mStack_.pop();\n    }\n  };\n\n  function matrixIsFinite(m) {\n    return isFinite(m[0][0]) && isFinite(m[0][1]) &&\n        isFinite(m[1][0]) && isFinite(m[1][1]) &&\n        isFinite(m[2][0]) && isFinite(m[2][1]);\n  }\n\n  function setM(ctx, m, updateLineScale) {\n    if (!matrixIsFinite(m)) {\n      return;\n    }\n    ctx.m_ = m;\n\n    if (updateLineScale) {\n      // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n      var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];\n      ctx.lineScale_ = sqrt(abs(det));\n    }\n  }\n\n  contextPrototype.translate = function(aX, aY) {\n    var m1 = [\n      [1,  0,  0],\n      [0,  1,  0],\n      [aX, aY, 1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), false);\n  };\n\n  contextPrototype.rotate = function(aRot) {\n    var c = mc(aRot);\n    var s = ms(aRot);\n\n    var m1 = [\n      [c,  s, 0],\n      [-s, c, 0],\n      [0,  0, 1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), false);\n  };\n\n  contextPrototype.scale = function(aX, aY) {\n    this.arcScaleX_ *= aX;\n    this.arcScaleY_ *= aY;\n    var m1 = [\n      [aX, 0,  0],\n      [0,  aY, 0],\n      [0,  0,  1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), true);\n  };\n\n  contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {\n    var m1 = [\n      [m11, m12, 0],\n      [m21, m22, 0],\n      [dx,  dy,  1]\n    ];\n\n    setM(this, matrixMultiply(m1, this.m_), true);\n  };\n\n  contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {\n    var m = [\n      [m11, m12, 0],\n      [m21, m22, 0],\n      [dx,  dy,  1]\n    ];\n\n    setM(this, m, true);\n  };\n\n  /**\n   * The text drawing function.\n   * The maxWidth argument isn't taken in account, since no browser supports\n   * it yet.\n   */\n  contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {\n    var m = this.m_,\n        delta = 1000,\n        left = 0,\n        right = delta,\n        offset = {x: 0, y: 0},\n        lineStr = [];\n\n    var fontStyle = getComputedStyle(processFontStyle(this.font),\n                                     this.element_);\n\n    var fontStyleString = buildStyle(fontStyle);\n\n    var elementStyle = this.element_.currentStyle;\n    var textAlign = this.textAlign.toLowerCase();\n    switch (textAlign) {\n      case 'left':\n      case 'center':\n      case 'right':\n        break;\n      case 'end':\n        textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';\n        break;\n      case 'start':\n        textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';\n        break;\n      default:\n        textAlign = 'left';\n    }\n\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    switch (this.textBaseline) {\n      case 'hanging':\n      case 'top':\n        offset.y = fontStyle.size / 1.75;\n        break;\n      case 'middle':\n        break;\n      default:\n      case null:\n      case 'alphabetic':\n      case 'ideographic':\n      case 'bottom':\n        offset.y = -fontStyle.size / 2.25;\n        break;\n    }\n\n    switch(textAlign) {\n      case 'right':\n        left = delta;\n        right = 0.05;\n        break;\n      case 'center':\n        left = right = delta / 2;\n        break;\n    }\n\n    var d = this.getCoords_(x + offset.x, y + offset.y);\n\n    lineStr.push('<g_vml_:line from=\"', -left ,' 0\" to=\"', right ,' 0.05\" ',\n                 ' coordsize=\"100 100\" coordorigin=\"0 0\"',\n                 ' filled=\"', !stroke, '\" stroked=\"', !!stroke,\n                 '\" style=\"position:absolute;width:1px;height:1px;\">');\n\n    if (stroke) {\n      appendStroke(this, lineStr);\n    } else {\n      // TODO: Fix the min and max params.\n      appendFill(this, lineStr, {x: -left, y: 0},\n                 {x: right, y: fontStyle.size});\n    }\n\n    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +\n                m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';\n\n    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);\n\n    lineStr.push('<g_vml_:skew on=\"t\" matrix=\"', skewM ,'\" ',\n                 ' offset=\"', skewOffset, '\" origin=\"', left ,' 0\" />',\n                 '<g_vml_:path textpathok=\"true\" />',\n                 '<g_vml_:textpath on=\"true\" string=\"',\n                 encodeHtmlAttribute(text),\n                 '\" style=\"v-text-align:', textAlign,\n                 ';font:', encodeHtmlAttribute(fontStyleString),\n                 '\" /></g_vml_:line>');\n\n    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));\n  };\n\n  contextPrototype.fillText = function(text, x, y, maxWidth) {\n    this.drawText_(text, x, y, maxWidth, false);\n  };\n\n  contextPrototype.strokeText = function(text, x, y, maxWidth) {\n    this.drawText_(text, x, y, maxWidth, true);\n  };\n\n  contextPrototype.measureText = function(text) {\n    if (!this.textMeasureEl_) {\n      var s = '<span style=\"position:absolute;' +\n          'top:-20000px;left:0;padding:0;margin:0;border:none;' +\n          'white-space:pre;\"></span>';\n      this.element_.insertAdjacentHTML('beforeEnd', s);\n      this.textMeasureEl_ = this.element_.lastChild;\n    }\n    var doc = this.element_.ownerDocument;\n    this.textMeasureEl_.innerHTML = '';\n    this.textMeasureEl_.style.font = this.font;\n    // Don't use innerHTML or innerText because they allow markup/whitespace.\n    this.textMeasureEl_.appendChild(doc.createTextNode(text));\n    return {width: this.textMeasureEl_.offsetWidth};\n  };\n\n  /******** STUBS ********/\n  contextPrototype.clip = function() {\n    // TODO: Implement\n  };\n\n  contextPrototype.arcTo = function() {\n    // TODO: Implement\n  };\n\n  contextPrototype.createPattern = function(image, repetition) {\n    return new CanvasPattern_(image, repetition);\n  };\n\n  // Gradient / Pattern Stubs\n  function CanvasGradient_(aType) {\n    this.type_ = aType;\n    this.x0_ = 0;\n    this.y0_ = 0;\n    this.r0_ = 0;\n    this.x1_ = 0;\n    this.y1_ = 0;\n    this.r1_ = 0;\n    this.colors_ = [];\n  }\n\n  CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {\n    aColor = processStyle(aColor);\n    this.colors_.push({offset: aOffset,\n                       color: aColor.color,\n                       alpha: aColor.alpha});\n  };\n\n  function CanvasPattern_(image, repetition) {\n    assertImageIsValid(image);\n    switch (repetition) {\n      case 'repeat':\n      case null:\n      case '':\n        this.repetition_ = 'repeat';\n        break\n      case 'repeat-x':\n      case 'repeat-y':\n      case 'no-repeat':\n        this.repetition_ = repetition;\n        break;\n      default:\n        throwException('SYNTAX_ERR');\n    }\n\n    this.src_ = image.src;\n    this.width_ = image.width;\n    this.height_ = image.height;\n  }\n\n  function throwException(s) {\n    throw new DOMException_(s);\n  }\n\n  function assertImageIsValid(img) {\n    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {\n      throwException('TYPE_MISMATCH_ERR');\n    }\n    if (img.readyState != 'complete') {\n      throwException('INVALID_STATE_ERR');\n    }\n  }\n\n  function DOMException_(s) {\n    this.code = this[s];\n    this.message = s +': DOM Exception ' + this.code;\n  }\n  var p = DOMException_.prototype = new Error;\n  p.INDEX_SIZE_ERR = 1;\n  p.DOMSTRING_SIZE_ERR = 2;\n  p.HIERARCHY_REQUEST_ERR = 3;\n  p.WRONG_DOCUMENT_ERR = 4;\n  p.INVALID_CHARACTER_ERR = 5;\n  p.NO_DATA_ALLOWED_ERR = 6;\n  p.NO_MODIFICATION_ALLOWED_ERR = 7;\n  p.NOT_FOUND_ERR = 8;\n  p.NOT_SUPPORTED_ERR = 9;\n  p.INUSE_ATTRIBUTE_ERR = 10;\n  p.INVALID_STATE_ERR = 11;\n  p.SYNTAX_ERR = 12;\n  p.INVALID_MODIFICATION_ERR = 13;\n  p.NAMESPACE_ERR = 14;\n  p.INVALID_ACCESS_ERR = 15;\n  p.VALIDATION_ERR = 16;\n  p.TYPE_MISMATCH_ERR = 17;\n\n  // set up externs\n  G_vmlCanvasManager = G_vmlCanvasManager_;\n  CanvasRenderingContext2D = CanvasRenderingContext2D_;\n  CanvasGradient = CanvasGradient_;\n  CanvasPattern = CanvasPattern_;\n  DOMException = DOMException_;\n})();\n\n} // if\n","/*! Javascript plotting library for jQuery, v. 0.7.\n *\n * Released under the MIT license by IOLA, December 2007.\n *\n */\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n * \n * Version 1.1.\n * \n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */ \n(function(B){B.color={};B.color.make=function(F,E,C,D){var G={};G.r=F||0;G.g=E||0;G.b=C||0;G.a=D!=null?D:1;G.add=function(J,I){for(var H=0;H<J.length;++H){G[J.charAt(H)]+=I}return G.normalize()};G.scale=function(J,I){for(var H=0;H<J.length;++H){G[J.charAt(H)]*=I}return G.normalize()};G.toString=function(){if(G.a>=1){return\"rgb(\"+[G.r,G.g,G.b].join(\",\")+\")\"}else{return\"rgba(\"+[G.r,G.g,G.b,G.a].join(\",\")+\")\"}};G.normalize=function(){function H(J,K,I){return K<J?J:(K>I?I:K)}G.r=H(0,parseInt(G.r),255);G.g=H(0,parseInt(G.g),255);G.b=H(0,parseInt(G.b),255);G.a=H(0,G.a,1);return G};G.clone=function(){return B.color.make(G.r,G.b,G.g,G.a)};return G.normalize()};B.color.extract=function(D,C){var E;do{E=D.css(C).toLowerCase();if(E!=\"\"&&E!=\"transparent\"){break}D=D.parent()}while(!B.nodeName(D.get(0),\"body\"));if(E==\"rgba(0, 0, 0, 0)\"){E=\"transparent\"}return B.color.parse(E)};B.color.parse=function(F){var E,C=B.color.make;if(E=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(F)){return C(parseInt(E[1],10),parseInt(E[2],10),parseInt(E[3],10))}if(E=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(F)){return C(parseInt(E[1],10),parseInt(E[2],10),parseInt(E[3],10),parseFloat(E[4]))}if(E=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(F)){return C(parseFloat(E[1])*2.55,parseFloat(E[2])*2.55,parseFloat(E[3])*2.55)}if(E=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(F)){return C(parseFloat(E[1])*2.55,parseFloat(E[2])*2.55,parseFloat(E[3])*2.55,parseFloat(E[4]))}if(E=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(F)){return C(parseInt(E[1],16),parseInt(E[2],16),parseInt(E[3],16))}if(E=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(F)){return C(parseInt(E[1]+E[1],16),parseInt(E[2]+E[2],16),parseInt(E[3]+E[3],16))}var D=B.trim(F).toLowerCase();if(D==\"transparent\"){return C(255,255,255,0)}else{E=A[D]||[0,0,0];return C(E[0],E[1],E[2])}};var A={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n        \n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85 // set to 0 to avoid background\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    \n                    // mode specific options\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null, // number or [number, \"unit\"]\n                    monthNames: null, // list of names of months\n                    timeformat: null, // format string to use\n                    twelveHourClock: false // 12 or 24 time in time mode\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled \n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // or \"center\" \n                        horizontal: false\n                    },\n                    shadowSize: 3\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                hooks: {}\n            },\n        canvas = null,      // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        canvasWidth = 0, canvasHeight = 0,\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return canvas; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.resize = function () {\n            getCanvasDimensions();\n            resizeCanvas(canvas);\n            resizeCanvas(overlay);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n        \n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n        \n        function parseOptions(opts) {\n            var i;\n            \n            $.extend(true, options, opts);\n            \n            if (options.xaxis.color == null)\n                options.xaxis.color = options.grid.color;\n            if (options.yaxis.color == null)\n                options.yaxis.color = options.grid.color;\n            \n            if (options.xaxis.tickColor == null) // backwards-compatibility\n                options.xaxis.tickColor = options.grid.tickColor;\n            if (options.yaxis.tickColor == null) // backwards-compatibility\n                options.yaxis.tickColor = options.grid.tickColor;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            \n            // fill in defaults in axes, copy at least always the\n            // first as the rest of the code assumes it'll be there\n            for (i = 0; i < Math.max(1, options.xaxes.length); ++i)\n                options.xaxes[i] = $.extend(true, {}, options.xaxis, options.xaxes[i]);\n            for (i = 0; i < Math.max(1, options.yaxes.length); ++i)\n                options.yaxes[i] = $.extend(true, {}, options.yaxis, options.yaxes[i]);\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n        \n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n        \n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n        \n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes \n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n            \n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n        \n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n            \n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n            \n            return res;\n        }\n        \n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n                \n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n            var i;\n            \n            // collect what we already got of colors\n            var neededColors = series.length,\n                usedColors = [],\n                assignedColors = [];\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    --neededColors;\n                    if (typeof sc == \"number\")\n                        assignedColors.push(sc);\n                    else\n                        usedColors.push($.color.parse(series[i].color));\n                }\n            }\n            \n            // we might need to generate more colors if higher indices\n            // are assigned\n            for (i = 0; i < assignedColors.length; ++i) {\n                neededColors = Math.max(neededColors, assignedColors[i] + 1);\n            }\n\n            // produce colors as needed\n            var colors = [], variation = 0;\n            i = 0;\n            while (colors.length < neededColors) {\n                var c;\n                if (options.colors.length == i) // check degenerate case\n                    c = $.color.make(100, 100, 100);\n                else\n                    c = $.color.parse(options.colors[i]);\n\n                // vary color if needed\n                var sign = variation % 2 == 1 ? -1 : 1;\n                c.scale('rgb', 1 + sign * Math.ceil(variation / 2) * 0.2)\n\n                // FIXME: if we're getting to close to something else,\n                // we should probably skip this one\n                colors.push(c);\n                \n                ++i;\n                if (i >= options.colors.length) {\n                    i = 0;\n                    ++variation;\n                }\n            }\n\n            // fill in the options\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                \n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n        \n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n            \n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n                \n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n            \n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                var data = s.data, format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        format.push({ y: true, number: true, required: false, defaultValue: 0 });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n                    \n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n                \n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n                \n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n                                    \n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n                            \n                            points[k + m] = val;\n                        }\n                    }\n                    \n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.x)\n                                    updateAxis(s.xaxis, val, val);\n                                if (f.y)\n                                    updateAxis(s.yaxis, val, val);\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                    else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0\n                            && points[k - ps] != null\n                            && points[k - ps] != points[k]\n                            && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m)\n                                points[k + ps + m] = points[k + m];\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                \n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points,\n                ps = s.datapoints.pointsize;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n                \n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n                        \n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n                \n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta = s.bars.align == \"left\" ? 0 : -s.bars.barWidth/2;\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n                \n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function makeCanvas(skipPositioning, cls) {\n            var c = document.createElement('canvas');\n            c.className = cls;\n            c.width = canvasWidth;\n            c.height = canvasHeight;\n                    \n            if (!skipPositioning)\n                $(c).css({ position: 'absolute', left: 0, top: 0 });\n                \n            $(c).appendTo(placeholder);\n                \n            if (!c.getContext) // excanvas hack\n                c = window.G_vmlCanvasManager.initElement(c);\n\n            // used for resetting in case we get replotted\n            c.getContext(\"2d\").save();\n            \n            return c;\n        }\n\n        function getCanvasDimensions() {\n            canvasWidth = placeholder.width();\n            canvasHeight = placeholder.height();\n            \n            if (canvasWidth <= 0 || canvasHeight <= 0)\n                throw new Error(\"Invalid dimensions for plot, width = \" + canvasWidth + \", height = \" + canvasHeight);\n        }\n\n        function resizeCanvas(c) {\n            // resizing should reset the state (excanvas seems to be\n            // buggy though)\n            if (c.width != canvasWidth)\n                c.width = canvasWidth;\n\n            if (c.height != canvasHeight)\n                c.height = canvasHeight;\n\n            // so try to get back to the initial state (even if it's\n            // gone now, this should be safe according to the spec)\n            var cctx = c.getContext(\"2d\");\n            cctx.restore();\n\n            // and save again\n            cctx.save();\n        }\n        \n        function setupCanvases() {\n            var reused,\n                existingCanvas = placeholder.children(\"canvas.base\"),\n                existingOverlay = placeholder.children(\"canvas.overlay\");\n\n            if (existingCanvas.length == 0 || existingOverlay == 0) {\n                // init everything\n                \n                placeholder.html(\"\"); // make sure placeholder is clear\n            \n                placeholder.css({ padding: 0 }); // padding messes up the positioning\n                \n                if (placeholder.css(\"position\") == 'static')\n                    placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n                getCanvasDimensions();\n                \n                canvas = makeCanvas(true, \"base\");\n                overlay = makeCanvas(false, \"overlay\"); // overlay canvas for interactive features\n\n                reused = false;\n            }\n            else {\n                // reuse existing elements\n\n                canvas = existingCanvas.get(0);\n                overlay = existingOverlay.get(0);\n\n                reused = true;\n            }\n\n            ctx = canvas.getContext(\"2d\");\n            octx = overlay.getContext(\"2d\");\n\n            // we include the canvas in the event holder too, because IE 7\n            // sometimes has trouble with the stacking order\n            eventHolder = $([overlay, canvas]);\n\n            if (reused) {\n                // run shutdown in the old plot object\n                placeholder.data(\"plot\").shutdown();\n\n                // reset reused canvases\n                plot.resize();\n                \n                // make sure overlay pixels are cleared (canvas is cleared when we redraw)\n                octx.clearRect(0, 0, canvasWidth, canvasHeight);\n                \n                // then whack any remaining obvious garbage left\n                eventHolder.unbind();\n                placeholder.children().not([canvas, overlay]).remove();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n                eventHolder.mouseleave(onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n            \n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n            \n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n            \n            function identity(x) { return x; }\n            \n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n            \n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n            var opts = axis.options, i, ticks = axis.ticks || [], labels = [],\n                l, w = opts.labelWidth, h = opts.labelHeight, dummyDiv;\n\n            function makeDummyDiv(labels, width) {\n                return $('<div style=\"position:absolute;top:-10000px;' + width + 'font-size:smaller\">' +\n                         '<div class=\"' + axis.direction + 'Axis ' + axis.direction + axis.n + 'Axis\">'\n                         + labels.join(\"\") + '</div></div>')\n                    .appendTo(placeholder);\n            }\n            \n            if (axis.direction == \"x\") {\n                // to avoid measuring the widths of the labels (it's slow), we\n                // construct fixed-size boxes and put the labels inside\n                // them, we don't need the exact figures and the\n                // fixed-size box content is easy to center\n                if (w == null)\n                    w = Math.floor(canvasWidth / (ticks.length > 0 ? ticks.length : 1));\n\n                // measure x label heights\n                if (h == null) {\n                    labels = [];\n                    for (i = 0; i < ticks.length; ++i) {\n                        l = ticks[i].label;\n                        if (l)\n                            labels.push('<div class=\"tickLabel\" style=\"float:left;width:' + w + 'px\">' + l + '</div>');\n                    }\n\n                    if (labels.length > 0) {\n                        // stick them all in the same div and measure\n                        // collective height\n                        labels.push('<div style=\"clear:left\"></div>');\n                        dummyDiv = makeDummyDiv(labels, \"width:10000px;\");\n                        h = dummyDiv.height();\n                        dummyDiv.remove();\n                    }\n                }\n            }\n            else if (w == null || h == null) {\n                // calculate y label dimensions\n                for (i = 0; i < ticks.length; ++i) {\n                    l = ticks[i].label;\n                    if (l)\n                        labels.push('<div class=\"tickLabel\">' + l + '</div>');\n                }\n                \n                if (labels.length > 0) {\n                    dummyDiv = makeDummyDiv(labels, \"\");\n                    if (w == null)\n                        w = dummyDiv.children().width();\n                    if (h == null)\n                        h = dummyDiv.find(\"div.tickLabel\").height();\n                    dummyDiv.remove();\n                }\n            }\n\n            if (w == null)\n                w = 0;\n            if (h == null)\n                h = 0;\n\n            axis.labelWidth = w;\n            axis.labelHeight = h;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                tickLength = axis.options.tickLength,\n                axismargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                all = axis.direction == \"x\" ? xaxes : yaxes,\n                index;\n\n            // determine axis margin\n            var samePosition = $.grep(all, function (a) {\n                return a && a.options.position == pos && a.reserveSpace;\n            });\n            if ($.inArray(axis, samePosition) == samePosition.length - 1)\n                axismargin = 0; // outermost\n\n            // determine tick length - if we're innermost, we can use \"full\"\n            if (tickLength == null)\n                tickLength = \"full\";\n\n            var sameDirection = $.grep(all, function (a) {\n                return a && a.reserveSpace;\n            });\n\n            var innermost = $.inArray(axis, sameDirection) == 0;\n            if (!innermost && tickLength == \"full\")\n                tickLength = 5;\n                \n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            // compute box\n            if (axis.direction == \"x\") {\n                lh += padding;\n                \n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axismargin;\n                    axis.box = { top: canvasHeight - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axismargin, height: lh };\n                    plotOffset.top += lh + axismargin;\n                }\n            }\n            else {\n                lw += padding;\n                \n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axismargin, width: lw };\n                    plotOffset.left += lw + axismargin;\n                }\n                else {\n                    plotOffset.right += lw + axismargin;\n                    axis.box = { left: canvasWidth - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // set remaining bounding box coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left;\n                axis.box.width = plotWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top;\n                axis.box.height = plotHeight;\n            }\n        }\n        \n        function setupGrid() {\n            var i, axes = allAxes();\n\n            // first calculate the plot and axis box dimensions\n\n            $.each(axes, function (_, axis) {\n                axis.show = axis.options.show;\n                if (axis.show == null)\n                    axis.show = axis.used; // by default an axis is visible if it's got data\n                \n                axis.reserveSpace = axis.show || axis.options.reserveSpace;\n\n                setRange(axis);\n            });\n\n            allocatedAxes = $.grep(axes, function (axis) { return axis.reserveSpace; });\n\n            plotOffset.left = plotOffset.right = plotOffset.top = plotOffset.bottom = 0;\n            if (options.grid.show) {\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions in house, we can compute the\n                // axis boxes, start from the outside (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                var minMargin = options.grid.minBorderMargin;\n                if (minMargin == null) {\n                    minMargin = 0;\n                    for (i = 0; i < series.length; ++i)\n                        minMargin = Math.max(minMargin, series[i].points.radius + series[i].points.lineWidth/2);\n                }\n                    \n                for (var a in plotOffset) {\n                    plotOffset[a] += options.grid.borderWidth;\n                    plotOffset[a] = Math.max(minMargin, plotOffset[a]);\n                }\n            }\n            \n            plotWidth = canvasWidth - plotOffset.left - plotOffset.right;\n            plotHeight = canvasHeight - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plotWidth/Height, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (options.grid.show) {\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n\n                insertAxisLabels();\n            }\n            \n            insertLegend();\n        }\n        \n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null)\n                    min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null)\n                    max += widen;\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n                \n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? canvasWidth : canvasHeight);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                size, generator, unit, formatter, i, magn, norm;\n\n            if (opts.mode == \"time\") {\n                // pretty handling of time\n                \n                // map of app. size of time units in milliseconds\n                var timeUnitSize = {\n                    \"second\": 1000,\n                    \"minute\": 60 * 1000,\n                    \"hour\": 60 * 60 * 1000,\n                    \"day\": 24 * 60 * 60 * 1000,\n                    \"month\": 30 * 24 * 60 * 60 * 1000,\n                    \"year\": 365.2425 * 24 * 60 * 60 * 1000\n                };\n\n\n                // the allowed tick sizes, after 1 year we use\n                // an integer algorithm\n                var spec = [\n                    [1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\n                    [30, \"second\"], \n                    [1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\n                    [30, \"minute\"], \n                    [1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\n                    [8, \"hour\"], [12, \"hour\"],\n                    [1, \"day\"], [2, \"day\"], [3, \"day\"],\n                    [0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\n                    [2, \"month\"], [3, \"month\"], [6, \"month\"],\n                    [1, \"year\"]\n                ];\n\n                var minSize = 0;\n                if (opts.minTickSize != null) {\n                    if (typeof opts.tickSize == \"number\")\n                        minSize = opts.tickSize;\n                    else\n                        minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n                }\n\n                for (var i = 0; i < spec.length - 1; ++i)\n                    if (delta < (spec[i][0] * timeUnitSize[spec[i][1]]\n                                 + spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\n                       && spec[i][0] * timeUnitSize[spec[i][1]] >= minSize)\n                        break;\n                size = spec[i][0];\n                unit = spec[i][1];\n                \n                // special-case the possibility of several years\n                if (unit == \"year\") {\n                    magn = Math.pow(10, Math.floor(Math.log(delta / timeUnitSize.year) / Math.LN10));\n                    norm = (delta / timeUnitSize.year) / magn;\n                    if (norm < 1.5)\n                        size = 1;\n                    else if (norm < 3)\n                        size = 2;\n                    else if (norm < 7.5)\n                        size = 5;\n                    else\n                        size = 10;\n\n                    size *= magn;\n                }\n\n                axis.tickSize = opts.tickSize || [size, unit];\n                \n                generator = function(axis) {\n                    var ticks = [],\n                        tickSize = axis.tickSize[0], unit = axis.tickSize[1],\n                        d = new Date(axis.min);\n                    \n                    var step = tickSize * timeUnitSize[unit];\n\n                    if (unit == \"second\")\n                        d.setUTCSeconds(floorInBase(d.getUTCSeconds(), tickSize));\n                    if (unit == \"minute\")\n                        d.setUTCMinutes(floorInBase(d.getUTCMinutes(), tickSize));\n                    if (unit == \"hour\")\n                        d.setUTCHours(floorInBase(d.getUTCHours(), tickSize));\n                    if (unit == \"month\")\n                        d.setUTCMonth(floorInBase(d.getUTCMonth(), tickSize));\n                    if (unit == \"year\")\n                        d.setUTCFullYear(floorInBase(d.getUTCFullYear(), tickSize));\n                    \n                    // reset smaller components\n                    d.setUTCMilliseconds(0);\n                    if (step >= timeUnitSize.minute)\n                        d.setUTCSeconds(0);\n                    if (step >= timeUnitSize.hour)\n                        d.setUTCMinutes(0);\n                    if (step >= timeUnitSize.day)\n                        d.setUTCHours(0);\n                    if (step >= timeUnitSize.day * 4)\n                        d.setUTCDate(1);\n                    if (step >= timeUnitSize.year)\n                        d.setUTCMonth(0);\n\n\n                    var carry = 0, v = Number.NaN, prev;\n                    do {\n                        prev = v;\n                        v = d.getTime();\n                        ticks.push(v);\n                        if (unit == \"month\") {\n                            if (tickSize < 1) {\n                                // a bit complicated - we'll divide the month\n                                // up but we need to take care of fractions\n                                // so we don't end up in the middle of a day\n                                d.setUTCDate(1);\n                                var start = d.getTime();\n                                d.setUTCMonth(d.getUTCMonth() + 1);\n                                var end = d.getTime();\n                                d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\n                                carry = d.getUTCHours();\n                                d.setUTCHours(0);\n                            }\n                            else\n                                d.setUTCMonth(d.getUTCMonth() + tickSize);\n                        }\n                        else if (unit == \"year\") {\n                            d.setUTCFullYear(d.getUTCFullYear() + tickSize);\n                        }\n                        else\n                            d.setTime(v + step);\n                    } while (v < axis.max && v != prev);\n\n                    return ticks;\n                };\n\n                formatter = function (v, axis) {\n                    var d = new Date(v);\n\n                    // first check global format\n                    if (opts.timeformat != null)\n                        return $.plot.formatDate(d, opts.timeformat, opts.monthNames);\n                    \n                    var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\n                    var span = axis.max - axis.min;\n                    var suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\n                    \n                    if (t < timeUnitSize.minute)\n                        fmt = \"%h:%M:%S\" + suffix;\n                    else if (t < timeUnitSize.day) {\n                        if (span < 2 * timeUnitSize.day)\n                            fmt = \"%h:%M\" + suffix;\n                        else\n                            fmt = \"%b %d %h:%M\" + suffix;\n                    }\n                    else if (t < timeUnitSize.month)\n                        fmt = \"%b %d\";\n                    else if (t < timeUnitSize.year) {\n                        if (span < timeUnitSize.year)\n                            fmt = \"%b\";\n                        else\n                            fmt = \"%b %y\";\n                    }\n                    else\n                        fmt = \"%y\";\n                    \n                    return $.plot.formatDate(d, fmt, opts.monthNames);\n                };\n            }\n            else {\n                // pretty rounding of base-10 numbers\n                var maxDec = opts.tickDecimals;\n                var dec = -Math.floor(Math.log(delta) / Math.LN10);\n                if (maxDec != null && dec > maxDec)\n                    dec = maxDec;\n\n                magn = Math.pow(10, -dec);\n                norm = delta / magn; // norm is between 1.0 and 10.0\n                \n                if (norm < 1.5)\n                    size = 1;\n                else if (norm < 3) {\n                    size = 2;\n                    // special case for 2.5, requires an extra decimal\n                    if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                        size = 2.5;\n                        ++dec;\n                    }\n                }\n                else if (norm < 7.5)\n                    size = 5;\n                else\n                    size = 10;\n\n                size *= magn;\n                \n                if (opts.minTickSize != null && size < opts.minTickSize)\n                    size = opts.minTickSize;\n\n                axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n                axis.tickSize = opts.tickSize || size;\n\n                generator = function (axis) {\n                    var ticks = [];\n\n                    // spew out all possible ticks\n                    var start = floorInBase(axis.min, axis.tickSize),\n                        i = 0, v = Number.NaN, prev;\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n                formatter = function (v, axis) {\n                    return v.toFixed(axis.tickDecimals);\n                };\n            }\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = generator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n                    \n                    generator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n                    \n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (axis.mode != \"time\" && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(delta) / Math.LN10) + 1),\n                            ts = generator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n\n            axis.tickGenerator = generator;\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n            else\n                axis.tickFormatter = formatter;\n        }\n        \n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks({ min: axis.min, max: axis.max });\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null)\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1)\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n      \n        function draw() {\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n            \n            if (grid.show && !grid.aboveData)\n                drawGrid();\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n            \n            if (grid.show && grid.aboveData)\n                drawGrid();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n            \n            return { from: from, to: to, axis: axis };\n        }\n        \n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i;\n            \n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    var axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n                    \n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    if (xrange.from == xrange.to && yrange.from == yrange.to)\n                        continue;\n\n                    // then draw\n                    xrange.from = xrange.axis.p2c(xrange.from);\n                    xrange.to = xrange.axis.p2c(xrange.to);\n                    yrange.from = yrange.axis.p2c(yrange.from);\n                    yrange.to = yrange.axis.p2c(yrange.to);\n                    \n                    if (xrange.from == xrange.to || yrange.from == yrange.to) {\n                        // draw line\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = m.lineWidth || options.grid.markingsLineWidth;\n                        ctx.moveTo(xrange.from, yrange.from);\n                        ctx.lineTo(xrange.to, yrange.to);\n                        ctx.stroke();\n                    }\n                    else {\n                        // fill area\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n            \n            // draw the ticks\n            var axes = allAxes(), bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue\n                \n                ctx.strokeStyle = axis.options.tickColor || $.color.parse(axis.options.color).scale('a', 0.22).toString();\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n                \n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth;\n                    else\n                        yoff = plotHeight;\n                    \n                    if (ctx.lineWidth == 1) {\n                        x = Math.floor(x) + 0.5;\n                        y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n                    \n                    xoff = yoff = 0;\n\n                    if (v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\" && bw > 0\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n                        \n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n                        \n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n                \n                ctx.stroke();\n            }\n            \n            \n            // draw border\n            if (bw) {\n                ctx.lineWidth = bw;\n                ctx.strokeStyle = options.grid.borderColor;\n                ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n            }\n\n            ctx.restore();\n        }\n\n        function insertAxisLabels() {\n            placeholder.find(\".tickLabels\").remove();\n            \n            var html = ['<div class=\"tickLabels\" style=\"font-size:smaller\">'];\n\n            var axes = allAxes();\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box;\n                if (!axis.show)\n                    continue;\n                //debug: html.push('<div style=\"position:absolute;opacity:0.10;background-color:red;left:' + box.left + 'px;top:' + box.top + 'px;width:' + box.width +  'px;height:' + box.height + 'px\"></div>')\n                html.push('<div class=\"' + axis.direction + 'Axis ' + axis.direction + axis.n + 'Axis\" style=\"color:' + axis.options.color + '\">');\n                for (var i = 0; i < axis.ticks.length; ++i) {\n                    var tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    var pos = {}, align;\n                    \n                    if (axis.direction == \"x\") {\n                        align = \"center\";\n                        pos.left = Math.round(plotOffset.left + axis.p2c(tick.v) - axis.labelWidth/2);\n                        if (axis.position == \"bottom\")\n                            pos.top = box.top + box.padding;\n                        else\n                            pos.bottom = canvasHeight - (box.top + box.height - box.padding);\n                    }\n                    else {\n                        pos.top = Math.round(plotOffset.top + axis.p2c(tick.v) - axis.labelHeight/2);\n                        if (axis.position == \"left\") {\n                            pos.right = canvasWidth - (box.left + box.width - box.padding)\n                            align = \"right\";\n                        }\n                        else {\n                            pos.left = box.left + box.padding;\n                            align = \"left\";\n                        }\n                    }\n\n                    pos.width = axis.labelWidth;\n\n                    var style = [\"position:absolute\", \"text-align:\" + align ];\n                    for (var a in pos)\n                        style.push(a + \":\" + pos[a] + \"px\")\n                    \n                    html.push('<div class=\"tickLabel\" style=\"' + style.join(';') + '\">' + tick.label + '</div>');\n                }\n                html.push('</div>');\n            }\n\n            html.push('</div>');\n\n            placeholder.append(html.join(\"\"));\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n        \n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n                \n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n                    \n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n                    \n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n                    \n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n                    \n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n                    \n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n                    \n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n                    \n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n                    \n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n                    \n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n            \n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, offset, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n           \n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n            \n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n            \n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n            \n            // fill the bar\n            if (fillStyleCallback) {\n                c.beginPath();\n                c.moveTo(left, bottom);\n                c.lineTo(left, top);\n                c.lineTo(right, top);\n                c.lineTo(right, bottom);\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fill();\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom + offset);\n                if (drawLeft)\n                    c.lineTo(left, top + offset);\n                else\n                    c.moveTo(left, top + offset);\n                if (drawTop)\n                    c.lineTo(right, top + offset);\n                else\n                    c.moveTo(right, top + offset);\n                if (drawRight)\n                    c.lineTo(right, bottom + offset);\n                else\n                    c.moveTo(right, bottom + offset);\n                if (drawBottom)\n                    c.lineTo(left, bottom + offset);\n                else\n                    c.moveTo(left, bottom + offset);\n                c.stroke();\n            }\n        }\n        \n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, offset, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n                \n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, offset, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n            var barLeft = series.bars.align == \"left\" ? 0 : -series.bars.barWidth/2;\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, 0, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n            \n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n        \n        function insertLegend() {\n            placeholder.find(\".legend\").remove();\n\n            if (!options.legend.show)\n                return;\n            \n            var fragments = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                label = s.label;\n                if (!label)\n                    continue;\n                \n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                if (lf)\n                    label = lf(label, s);\n                \n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + s.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + label + '</td>');\n            }\n            if (rowStarted)\n                fragments.push('</tr>');\n            \n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n        \n        var highlights = [],\n            redrawTimeout = null;\n        \n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n                \n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    ps = s.datapoints.pointsize,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n                \n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n                        \n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n                    \n                if (s.bars.show && !item) { // no other point can be nearby\n                    var barLeft = s.bars.align == \"left\" ? 0 : -s.bars.barWidth/2,\n                        barRight = barLeft + s.bars.barWidth;\n                    \n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n  \n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ? \n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) && \n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n                \n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n            \n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e,\n                                   function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n                \n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n            \n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, 30);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            octx.clearRect(0, 0, canvasWidth, canvasHeight);\n            octx.translate(plotOffset.left, plotOffset.top);\n            \n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n            \n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n        \n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n            \n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n            }\n            \n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\")\n                point = s.data[point];\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n        \n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n        \n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis;\n            \n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n            \n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = $.color.parse(series.color).scale('a', 0.5).toString();\n            var radius = 1.5 * pointRadius,\n                x = axisx.p2c(x),\n                y = axisy.p2c(y);\n            \n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = $.color.parse(series.color).scale('a', 0.5).toString();\n            var fillStyle = $.color.parse(series.color).scale('a', 0.5).toString();\n            var barLeft = series.bars.align == \"left\" ? 0 : -series.bars.barWidth/2;\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    0, function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n                \n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness)\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n                \n                return gradient;\n            }\n        }\n    }\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.7\";\n    \n    $.plot.plugins = [];\n\n    // returns a string with the date d formatted according to fmt\n    $.plot.formatDate = function(d, fmt, monthNames) {\n        var leftPad = function(n) {\n            n = \"\" + n;\n            return n.length == 1 ? \"0\" + n : n;\n        };\n        \n        var r = [];\n        var escape = false, padNext = false;\n        var hours = d.getUTCHours();\n        var isAM = hours < 12;\n        if (monthNames == null)\n            monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n        if (fmt.search(/%p|%P/) != -1) {\n            if (hours > 12) {\n                hours = hours - 12;\n            } else if (hours == 0) {\n                hours = 12;\n            }\n        }\n        for (var i = 0; i < fmt.length; ++i) {\n            var c = fmt.charAt(i);\n            \n            if (escape) {\n                switch (c) {\n                case 'h': c = \"\" + hours; break;\n                case 'H': c = leftPad(hours); break;\n                case 'M': c = leftPad(d.getUTCMinutes()); break;\n                case 'S': c = leftPad(d.getUTCSeconds()); break;\n                case 'd': c = \"\" + d.getUTCDate(); break;\n                case 'm': c = \"\" + (d.getUTCMonth() + 1); break;\n                case 'y': c = \"\" + d.getUTCFullYear(); break;\n                case 'b': c = \"\" + monthNames[d.getUTCMonth()]; break;\n                case 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\n                case 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\n                case '0': c = \"\"; padNext = true; break;\n                }\n                if (c && padNext) {\n                    c = leftPad(c);\n                    padNext = false;\n                }\n                r.push(c);\n                if (!padNext)\n                    escape = false;\n            }\n            else {\n                if (c == \"%\")\n                    escape = true;\n                else\n                    r.push(c);\n            }\n        }\n        return r.join(\"\");\n    };\n    \n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n    \n})(jQuery);\n","\n(function($){$.fn.editable=function(target,options){if('disable'==target){$(this).data('disabled.editable',true);return;}\nif('enable'==target){$(this).data('disabled.editable',false);return;}\nif('destroy'==target){$(this).unbind($(this).data('event.editable')).removeData('disabled.editable').removeData('event.editable');return;}\nvar settings=$.extend({},$.fn.editable.defaults,{target:target},options);var plugin=$.editable.types[settings.type].plugin||function(){};var submit=$.editable.types[settings.type].submit||function(){};var buttons=$.editable.types[settings.type].buttons||$.editable.types['defaults'].buttons;var content=$.editable.types[settings.type].content||$.editable.types['defaults'].content;var element=$.editable.types[settings.type].element||$.editable.types['defaults'].element;var reset=$.editable.types[settings.type].reset||$.editable.types['defaults'].reset;var callback=settings.callback||function(){};var onedit=settings.onedit||function(){};var onsubmit=settings.onsubmit||function(){};var onreset=settings.onreset||function(){};var onerror=settings.onerror||reset;if(settings.tooltip){$(this).attr('title',settings.tooltip);}\nsettings.autowidth='auto'==settings.width;settings.autoheight='auto'==settings.height;return this.each(function(){var self=this;var savedwidth=$(self).width();var savedheight=$(self).height();$(this).data('event.editable',settings.event);if(!$.trim($(this).html())){$(this).html(settings.placeholder);}\n$(this).bind(settings.event,function(e){if(true===$(this).data('disabled.editable')){return;}\nif(self.editing){return;}\nif(false===onedit.apply(this,[settings,self])){return;}\ne.preventDefault();e.stopPropagation();if(settings.tooltip){$(self).removeAttr('title');}\nif(0==$(self).width()){settings.width=savedwidth;settings.height=savedheight;}else{if(settings.width!='none'){settings.width=settings.autowidth?$(self).width():settings.width;}\nif(settings.height!='none'){settings.height=settings.autoheight?$(self).height():settings.height;}}\nif($(this).html().toLowerCase().replace(/(;|\")/g,'')==settings.placeholder.toLowerCase().replace(/(;|\")/g,'')){$(this).html('');}\nself.editing=true;self.revert=$(self).html();$(self).html('');var form=$('<form />');if(settings.cssclass){if('inherit'==settings.cssclass){form.attr('class',$(self).attr('class'));}else{form.attr('class',settings.cssclass);}}\nif(settings.style){if('inherit'==settings.style){form.attr('style',$(self).attr('style'));form.css('display',$(self).css('display'));}else{form.attr('style',settings.style);}}\nvar input=element.apply(form,[settings,self]);var input_content;if(settings.loadurl){var t=setTimeout(function(){input.disabled=true;content.apply(form,[settings.loadtext,settings,self]);},100);var loaddata={};loaddata[settings.id]=self.id;if($.isFunction(settings.loaddata)){$.extend(loaddata,settings.loaddata.apply(self,[self.revert,settings]));}else{$.extend(loaddata,settings.loaddata);}\n$.ajax({type:settings.loadtype,url:settings.loadurl,data:loaddata,async:false,success:function(result){window.clearTimeout(t);input_content=result;input.disabled=false;}});}else if(settings.data){input_content=settings.data;if($.isFunction(settings.data)){input_content=settings.data.apply(self,[self.revert,settings]);}}else{input_content=self.revert;}\ncontent.apply(form,[input_content,settings,self]);input.attr('name',settings.name);buttons.apply(form,[settings,self]);$(self).append(form);plugin.apply(form,[settings,self]);$(':input:visible:enabled:first',form).focus();if(settings.select){input.select();}\ninput.keydown(function(e){if(e.keyCode==27){e.preventDefault();reset.apply(form,[settings,self]);}});var t;if('cancel'==settings.onblur){input.blur(function(e){t=setTimeout(function(){reset.apply(form,[settings,self]);},500);});}else if('submit'==settings.onblur){input.blur(function(e){t=setTimeout(function(){form.submit();},200);});}else if($.isFunction(settings.onblur)){input.blur(function(e){settings.onblur.apply(self,[input.val(),settings]);});}else{input.blur(function(e){});}\nform.submit(function(e){if(t){clearTimeout(t);}\ne.preventDefault();if(false!==onsubmit.apply(form,[settings,self])){if(false!==submit.apply(form,[settings,self])){if($.isFunction(settings.target)){var str=settings.target.apply(self,[input.val(),settings]);$(self).html(str);self.editing=false;callback.apply(self,[self.innerHTML,settings]);if(!$.trim($(self).html())){$(self).html(settings.placeholder);}}else{var submitdata={};submitdata[settings.name]=input.val();submitdata[settings.id]=self.id;if($.isFunction(settings.submitdata)){$.extend(submitdata,settings.submitdata.apply(self,[self.revert,settings]));}else{$.extend(submitdata,settings.submitdata);}\nif('PUT'==settings.method){submitdata['_method']='put';}\n$(self).html(settings.indicator);var ajaxoptions={type:'POST',data:submitdata,dataType:'html',url:settings.target,success:function(result,status){if(ajaxoptions.dataType=='html'){$(self).html(result);}\nself.editing=false;callback.apply(self,[result,settings]);if(!$.trim($(self).html())){$(self).html(settings.placeholder);}},error:function(xhr,status,error){onerror.apply(form,[settings,self,xhr]);}};$.extend(ajaxoptions,settings.ajaxoptions);$.ajax(ajaxoptions);}}}\n$(self).attr('title',settings.tooltip);return false;});});this.reset=function(form){if(this.editing){if(false!==onreset.apply(form,[settings,self])){$(self).html(self.revert);self.editing=false;if(!$.trim($(self).html())){$(self).html(settings.placeholder);}\nif(settings.tooltip){$(self).attr('title',settings.tooltip);}}}};});};$.editable={types:{defaults:{element:function(settings,original){var input=$('<input type=\"hidden\"></input>');$(this).append(input);return(input);},content:function(string,settings,original){$(':input:first',this).val(string);},reset:function(settings,original){original.reset(this);},buttons:function(settings,original){var form=this;if(settings.submit){if(settings.submit.match(/>$/)){var submit=$(settings.submit).click(function(){if(submit.attr(\"type\")!=\"submit\"){form.submit();}});}else{var submit=$('<button type=\"submit\" />');submit.html(settings.submit);}\n$(this).append(submit);}\nif(settings.cancel){if(settings.cancel.match(/>$/)){var cancel=$(settings.cancel);}else{var cancel=$('<button type=\"cancel\" />');cancel.html(settings.cancel);}\n$(this).append(cancel);$(cancel).click(function(event){if($.isFunction($.editable.types[settings.type].reset)){var reset=$.editable.types[settings.type].reset;}else{var reset=$.editable.types['defaults'].reset;}\nreset.apply(form,[settings,original]);return false;});}}},text:{element:function(settings,original){var input=$('<input />');if(settings.width!='none'){input.width(settings.width);}\nif(settings.height!='none'){input.height(settings.height);}\ninput.attr('autocomplete','off');$(this).append(input);return(input);}},textarea:{element:function(settings,original){var textarea=$('<textarea />');if(settings.rows){textarea.attr('rows',settings.rows);}else if(settings.height!=\"none\"){textarea.height(settings.height);}\nif(settings.cols){textarea.attr('cols',settings.cols);}else if(settings.width!=\"none\"){textarea.width(settings.width);}\n$(this).append(textarea);return(textarea);}},select:{element:function(settings,original){var select=$('<select />');$(this).append(select);return(select);},content:function(data,settings,original){if(String==data.constructor){eval('var json = '+data);}else{var json=data;}\nfor(var key in json){if(!json.hasOwnProperty(key)){continue;}\nif('selected'==key){continue;}\nvar option=$('<option />').val(key).append(json[key]);$('select',this).append(option);}\n$('select',this).children().each(function(){if($(this).val()==json['selected']||$(this).text()==$.trim(original.revert)){$(this).attr('selected','selected');}});}}},addInputType:function(name,input){$.editable.types[name]=input;}};$.fn.editable.defaults={name:'value',id:'id',type:'text',width:'auto',height:'auto',event:'click.editable',onblur:'cancel',loadtype:'GET',loadtext:'Loading...',placeholder:'Click to edit',loaddata:{},submitdata:{},ajaxoptions:{}};})(jQuery);"],"sourceRoot":"webpack:///","file":"src_app_core_augmenting_dynamic-scripts_backlogs_js.8412d11a76ae9a307f9c.js"}